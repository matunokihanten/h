<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>🔥アツい記憶チャレンジ🔥 NEO</title>
  <style>
    :root {
      --bg-color: #f0f2f5;
      --panel-bg: #fff;
      --text-color: #333;
      --primary-color: #fcbf49;
      --correct-color: #2ecc71;
      --wrong-color: #e74c3c;
      --border-color: #ddd;
      --border-hover: #333;
    }
    body {
      font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      text-align: center;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .screen {
      display: none; /* Initially hide all screens */
      width: 100%;
      max-width: 420px;
    }
    .screen.active {
      display: block;
    }
    h1 {
      margin-bottom: 5px;
      color: var(--primary-color);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    p { margin: 0 0 20px; }
    button {
      font-size: 1.2em;
      padding: 12px 30px;
      border-radius: 50px;
      border: none;
      background: var(--primary-color);
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-top: 10px; /* Added for mode selection buttons */
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 15px rgba(0,0,0,0.2);
    }
    #game-container {
      background: var(--panel-bg);
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    #scoreboard {
      font-size: 1.1em;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-around;
      gap: 10px;
    }
    #timerBar {
      width: 100%; height: 12px;
      background: var(--border-color); margin: 0 auto 20px;
      border-radius: 6px; overflow: hidden;
    }
    #timerFill {
      height: 100%;
      background: linear-gradient(90deg, var(--correct-color), var(--primary-color), var(--wrong-color));
      width: 100%;
      transition: width 0.1s linear;
    }
    #svgPanel {
      width: 180px; height: 180px;
      margin: 0 auto 10px;
      border: 4px solid var(--border-hover);
      border-radius: 12px;
      transition: transform 0.3s ease-in-out;
    }
    #question {
      font-weight: bold;
      font-size: 1.2em;
      margin: 10px 0;
      min-height: 1.5em;
    }
    #choices, #colorChoices {
      display: grid;
      grid-template-columns: repeat(3, 1fr); /* Changed to 3 columns */
      gap: 15px;
      margin-top: 15px;
    }
    .choice {
      aspect-ratio: 1 / 1;
      border: 2px solid var(--border-color);
      background: var(--panel-bg);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform .2s, border-color .2s;
      border-radius: 8px;
    }
    .choice:hover {
      transform: scale(1.05);
      border-color: var(--border-hover);
    }
    .choice.selected {
      border-color: var(--primary-color);
      box-shadow: 0 0 10px var(--primary-color);
      transform: scale(1.05);
    }
    .choice.disabled {
      pointer-events: none;
      opacity: 0.5;
    }
    .label { font-size: 14px; margin-top: 5px; font-weight: bold; }
    .color-box {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 2px solid var(--border-color);
        box-sizing: border-box;
    }
    #message { margin-top: 15px; font-size: 1.2em; font-weight: bold; min-height: 1.5em; }
    .correct { color: var(--correct-color); }
    .wrong { color: var(--wrong-color); }

    /* Game Over Screen Specific Styles */
    #gameover-screen #final-score, 
    #gameover-screen #high-score,
    #gameover-screen .analysis-item {
        font-size: 1.1em;
        font-weight: bold;
        display: block;
        margin: 8px 0;
    }
    #gameover-screen h1 {
        margin-bottom: 20px;
    }
    #analysis-results {
        margin-top: 20px;
        padding-top: 15px;
        border-top: 1px solid var(--border-color);
    }
    #average-time-chart-container {
        width: 100%;
        max-width: 400px; /* Adjust as needed */
        margin: 20px auto 0;
        background: #fdfdfd;
        border-radius: 8px;
        padding: 10px;
        box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
    }
    /* End button specific styles */
    #end-game-btn {
        background: #e74c3c; /* Red color for end button */
        margin-top: 20px;
        padding: 10px 25px;
        font-size: 1em;
        box-shadow: 0 3px 8px rgba(0,0,0,0.1);
    }
    #end-game-btn:hover {
        transform: scale(1.03);
        box-shadow: 0 5px 12px rgba(0,0,0,0.2);
    }

    /* Animations */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    @keyframes flash-correct {
      from { border-color: var(--correct-color); box-shadow: 0 0 15px var(--correct-color); }
      to { border-color: var(--border-hover); box-shadow: none; }
    }
    .shake { animation: shake 0.3s ease-in-out; }
    .flash-correct { animation: flash-correct 0.5s ease-out; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <div id="main-container">
    <div id="start-screen" class="screen active">
      <h1>🔥アツい記憶チャレンジ🔥 NEO</h1>
      <p>次々と表示される図形を記憶し、<br>「N個前の図形」を当てよう！</p>
      <button id="normal-mode-btn">ノーマルモード (1個前)</button>
      <button id="color-shape-mode-btn">色&形モード (直前)</button>
      <button id="hard-mode-btn">ハードモード (N個前)</button>
      <button id="timed-analysis-mode-btn">タイムアタック＆分析モード</button>
    </div>

    <div id="game-screen" class="screen">
      <div id="game-container">
        <div id="scoreboard">
          <span>❤️ <span id="lives">3</span></span>
          <span>スコア: <span id="score">0</span></span>
          <span>連勝: <span id="streak">0</span></span>
          <span>Lv: <span id="level">1</span></span>
        </div>
        <div id="timerBar"><div id="timerFill"></div></div>

        <svg id="svgPanel" viewBox="0 0 200 200"></svg>
        <div id="question"></div>
        <div id="choices"></div>
        <div id="colorChoices"></div>
        <div id="message"></div>
        <button id="end-game-btn" style="display: none;">終了</button>
      </div>
    </div>

    <div id="gameover-screen" class="screen">
        <h1>ゲームオーバー</h1>
        <div id="default-gameover-stats">
            <div>あなたのスコア: <span id="final-score">0</span></div>
            <div>ハイスコア: <span id="high-score">0</span></div>
        </div>
        
        <div id="analysis-results" style="display: none;">
            <h2>分析結果</h2>
            <div class="analysis-item">解答問題数: <span id="answered-questions-count">0</span></div>
            <div class="analysis-item">正解数: <span id="correct-answers-count">0</span></div>
            <div class="analysis-item">間違い数: <span id="wrong-answers-count">0</span></div>
            <div class="analysis-item">平均解答時間: <span id="average-response-time">0</span>ms</div>
            <div id="average-time-chart-container">
                <canvas id="responseTimeChart"></canvas>
            </div>
        </div>

        <br>
        <button id="retry-btn">もう一度挑戦</button>
        <button id="back-to-menu-btn">モード選択に戻る</button>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // --- 図形データ ---
  const shapeDefs = [
    { name:'まる',   draw: (c, svg) => svg.innerHTML = `<circle cx="100" cy="100" r="60" fill="${c}"/>` },
    { name:'しかく', draw: (c, svg) => svg.innerHTML = `<rect x="50" y="50" width="100" height="100" fill="${c}"/>` },
    { name:'さんかく',draw: (c, svg) => svg.innerHTML = `<polygon points="100,30 170,170 30,170" fill="${c}"/>` },
    { name:'ほし',   draw: (c, svg) => svg.innerHTML = `<polygon points="100,10 120,80 190,80 135,125 150,195 100,155 50,195 65,125 10,80 80,80" fill="${c}"/>` },
    { name:'ひし', draw: (c, svg) => svg.innerHTML = `<polygon points="100,20 180,100 100,180 20,100" fill="${c}"/>` },
    { name:'じゅうじ', draw: (c, svg) => svg.innerHTML = `<rect x="80" y="30" width="40" height="140" fill="${c}"/><rect x="30" y="80" width="140" height="40" fill="${c}"/>` }
  ];
  const colors = ['#ff6666', '#808080', '#99ff99', '#fcbf49', '#8e44ad', '#3498db'];
  const colorNames = ['赤', '灰色', '緑', '黄', '紫', '青'];

  // --- ゲーム状態 ---
  let gameState = {};
  let gameMode = 'hard'; // 'normal', 'hard', 'color-shape', 'timed-analysis'
  let selectedShapeIndex = -1; // For 'color-shape' mode
  let selectedColorIndex = -1; // For 'color-shape' mode
  let roundStartTime = 0; // For timed-analysis mode
  let responseTimes = []; // To store response times for timed-analysis mode
  let correctAnswersCount = 0; // For timed-analysis mode
  let wrongAnswersCount = 0; // For timed-analysis mode
  let myChart = null; // Chart.js instance

  // --- DOM要素 ---
  const screens = {
    start: document.getElementById('start-screen'),
    game: document.getElementById('game-screen'),
    gameOver: document.getElementById('gameover-screen')
  };
  const svgPanel = document.getElementById('svgPanel');
  const choicesEl = document.getElementById('choices');
  const colorChoicesEl = document.getElementById('colorChoices');
  const messageEl = document.getElementById('message');
  const questionEl = document.getElementById('question');
  const livesEl = document.getElementById('lives');
  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const levelEl = document.getElementById('level');
  const timerBar = document.getElementById('timerBar');
  const timerFill = document.getElementById('timerFill');
  const finalScoreEl = document.getElementById('final-score');
  const highScoreEl = document.getElementById('high-score');
  const endGameBtn = document.getElementById('end-game-btn');
  const defaultGameoverStats = document.getElementById('default-gameover-stats');
  const analysisResults = document.getElementById('analysis-results');
  const answeredQuestionsCountEl = document.getElementById('answered-questions-count');
  const correctAnswersCountEl = document.getElementById('correct-answers-count');
  const wrongAnswersCountEl = document.getElementById('wrong-answers-count');
  const averageResponseTimeEl = document.getElementById('average-response-time');
  const responseTimeChartCanvas = document.getElementById('responseTimeChart');

  // --- サウンド ---
  let audioCtx;
  function playSound(type) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g);
    g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
    
    if (type === 'correct') {
      o.type = 'triangle';
      o.frequency.value = 880;
    } else if (type === 'wrong') {
      o.type = 'sawtooth';
      o.frequency.value = 220;
    } else { // level up
      o.type = 'sine';
      o.frequency.value = 1200;
    }
    o.start(audioCtx.currentTime);
    o.stop(audioCtx.currentTime + 0.2);
  }

  // --- 画面切り替え ---
  function showScreen(screenId) {
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens[screenId].classList.add('active');
  }

  // --- ハイスコア処理 ---
  function loadHighScore(mode) {
    return localStorage.getItem('memoryGameHighScore_' + mode) || 0;
  }
  function saveHighScore(score, mode) {
    const highScore = loadHighScore(mode);
    if (score > highScore) {
      localStorage.setItem('memoryGameHighScore_' + mode, score);
    }
  }

  // --- ゲームロジック ---
  function resetGameState() {
    gameState = {
      history: [],
      score: 0,
      streak: 0,
      level: 1,
      lives: 3,
      nBack: (gameMode === 'hard' ? 1 : 1),
      roundTime: 4000,
      answerAllowed: false,
      timerInterval: null
    };
    selectedShapeIndex = -1;
    selectedColorIndex = -1;
    roundStartTime = 0;
    responseTimes = [];
    correctAnswersCount = 0;
    wrongAnswersCount = 0;

    updateUI();
    toggleChoiceVisibility(); 
    toggleGameElementsVisibility(); 
  }

  function startGame(mode) {
    gameMode = mode;
    resetGameState();
    showScreen('game');
    setTimeout(nextRound, 500);
  }

  function gameOver() {
    gameState.answerAllowed = false;
    clearInterval(gameState.timerInterval);
    
    if (gameMode !== 'timed-analysis') {
        saveHighScore(gameState.score, gameMode);
        finalScoreEl.textContent = gameState.score;
        highScoreEl.textContent = loadHighScore(gameMode);
        defaultGameoverStats.style.display = 'block';
        analysisResults.style.display = 'none';
    } else {
        answeredQuestionsCountEl.textContent = responseTimes.length;
        correctAnswersCountEl.textContent = correctAnswersCount;
        wrongAnswersCountEl.textContent = wrongAnswersCount;
        
        const totalTime = responseTimes.reduce((sum, time) => sum + time, 0);
        const averageTime = responseTimes.length > 0 ? (totalTime / responseTimes.length).toFixed(0) : 0;
        averageResponseTimeEl.textContent = averageTime;

        drawResponseTimeChart(responseTimes);

        defaultGameoverStats.style.display = 'none';
        analysisResults.style.display = 'block';
    }
    showScreen('gameOver');
  }

  function updateScore(correct) {
    if (gameMode === 'timed-analysis') {
        if (correct) {
            correctAnswersCount++;
        } else {
            wrongAnswersCount++;
        }
    } else {
        if (correct) {
            gameState.streak++;
            gameState.score += 10 * gameState.streak * gameState.nBack;
            if (gameMode === 'hard') {
                if (gameState.streak > 0 && gameState.streak % 4 === 0) {
                    gameState.level++;
                    playSound('level-up');
                    gameState.roundTime = Math.max(1500, gameState.roundTime - 400);
                    if (gameState.level >= 5 && gameState.level % 4 === 1) {
                        gameState.nBack = Math.min(3, gameState.nBack + 1);
                    }
                }
            } else {
                if (gameState.streak > 0 && gameState.streak % 5 === 0) {
                    gameState.level++;
                    playSound('level-up');
                    gameState.roundTime = Math.max(2000, gameState.roundTime - 200);
                }
            }
        } else {
            gameState.streak = 0;
            gameState.lives--;
            svgPanel.parentElement.classList.add('shake');
            setTimeout(() => svgPanel.parentElement.classList.remove('shake'), 300);
            if (gameState.lives <= 0) {
                setTimeout(gameOver, 500);
                return;
            }
        }
    }
    updateUI();
  }

  function updateUI() {
    scoreEl.textContent = gameState.score;
    streakEl.textContent = gameState.streak;
    levelEl.textContent = gameState.level;
    livesEl.textContent = gameState.lives;

    const scoreboard = document.getElementById('scoreboard');
    if (gameMode === 'timed-analysis') {
        scoreboard.style.display = 'none';
    } else {
        scoreboard.style.display = 'flex';
    }
  }

  function nextRound() {
    messageEl.textContent = '';
    messageEl.className = '';
    choicesEl.querySelectorAll('.choice').forEach(c => c.classList.remove('disabled', 'selected'));
    colorChoicesEl.querySelectorAll('.choice').forEach(c => c.classList.remove('disabled', 'selected'));
    selectedShapeIndex = -1;
    selectedColorIndex = -1;

    let newShapeIndex;
    let newColorIndex;
    
    do {
      newShapeIndex = Math.floor(Math.random() * shapeDefs.length);
    } while (gameState.history.length > 0 &&
             newShapeIndex === gameState.history[0].shapeIndex);
    
    newColorIndex = Math.floor(Math.random() * colors.length);

    gameState.history.unshift({ shapeIndex: newShapeIndex, colorIndex: newColorIndex });
    
    const maxHistoryLength = (gameMode === 'hard' ? 4 : 2);
    if (gameState.history.length > maxHistoryLength) {
        gameState.history.pop();
    }

    shapeDefs[newShapeIndex].draw(colors[newColorIndex], svgPanel);
    svgPanel.style.transform = 'scale(1.05)';
    setTimeout(() => svgPanel.style.transform = 'scale(1)', 200);

    const currentNBack = (gameMode === 'hard' ? gameState.nBack : 1);

    if (gameState.history.length > currentNBack) {
      if (gameMode === 'color-shape') {
        questionEl.textContent = `🔥 直前の「形と色」は？`;
      } else {
        questionEl.textContent = `🔥 ${currentNBack}個前の形は？`;
      }
      startRoundTimer();
      toggleChoiceVisibility(true);
    } else {
      questionEl.textContent = '覚えてね！';
      toggleChoiceVisibility(false);
      setTimeout(nextRound, 1000);
    }
  }

  function startRoundTimer() {
    gameState.answerAllowed = true;
    roundStartTime = performance.now();

    if (gameMode !== 'timed-analysis') {
        let timeLeft = gameState.roundTime;
        clearInterval(gameState.timerInterval);
        timerFill.style.transition = 'none'; 
        timerFill.style.width = '100%';
        
        timerFill.offsetHeight; 
        timerFill.style.transition = `width ${gameState.roundTime / 1000}s linear`;
        timerFill.style.width = '0%';
        
        gameState.timerInterval = setTimeout(() => {
          if(gameState.answerAllowed) {
            processAnswer(null, null); 
          }
        }, gameState.roundTime);
    } else {
        clearInterval(gameState.timerInterval);
    }
  }

  function processAnswer(shapeIdx, colorIdx) {
    let responseTime = 0;
    if (gameMode === 'timed-analysis' && roundStartTime > 0) {
        responseTime = performance.now() - roundStartTime;
        roundStartTime = 0;
    }

    if (!gameState.answerAllowed && gameMode !== 'color-shape' && gameMode !== 'timed-analysis') return;
    
    if (gameMode === 'color-shape') {
      if (shapeIdx !== null) selectedShapeIndex = shapeIdx;
      if (colorIdx !== null) selectedColorIndex = colorIdx;

      choicesEl.querySelectorAll('.choice').forEach((c, i) => {
        c.classList.toggle('selected', i === selectedShapeIndex);
      });
      colorChoicesEl.querySelectorAll('.choice').forEach((c, i) => {
        c.classList.toggle('selected', i === selectedColorIndex);
      });

      if (selectedShapeIndex === -1 || selectedColorIndex === -1) {
        return;
      }
    } else {
        if (!gameState.answerAllowed && gameMode !== 'timed-analysis') return;
        selectedShapeIndex = shapeIdx;
    }

    gameState.answerAllowed = false;
    clearTimeout(gameState.timerInterval);

    const currentNBack = (gameMode === 'hard' ? gameState.nBack : 1);
    const correctTarget = gameState.history[currentNBack];
    
    let isCorrect = false;
    if (gameMode === 'color-shape') {
      isCorrect = (selectedShapeIndex == correctTarget.shapeIndex && selectedColorIndex == correctTarget.colorIndex);
    } else {
      isCorrect = (selectedShapeIndex == correctTarget.shapeIndex);
    }

    playSound(isCorrect ? 'correct' : 'wrong');
    updateScore(isCorrect);
    
    if (gameMode === 'timed-analysis' && shapeIdx !== null) {
        responseTimes.push(responseTime);
    }

    choicesEl.querySelectorAll('.choice').forEach(c => c.classList.add('disabled'));
    colorChoicesEl.querySelectorAll('.choice').forEach(c => c.classList.add('disabled'));

    if (shapeIdx === null && colorIdx === null && gameMode !== 'timed-analysis') {
      let messageText = `⏰ 時間切れ… 正解は『${shapeDefs[correctTarget.shapeIndex].name}』`;
      if (gameMode === 'color-shape') {
        messageText += `の『${colorNames[correctTarget.colorIndex]}』`;
      }
      messageEl.textContent = messageText;
      messageEl.className = 'wrong';
    } else if (isCorrect) {
      messageEl.textContent = `✅ 正解！`;
      messageEl.className = 'correct';
      svgPanel.classList.add('flash-correct');
      setTimeout(()=> svgPanel.classList.remove('flash-correct'), 500);
    } else {
      let messageText = `❌ 不正解… 正解は『${shapeDefs[correctTarget.shapeIndex].name}』`;
      if (gameMode === 'color-shape') {
        messageText += `の『${colorNames[correctTarget.colorIndex]}』`;
      }
      messageEl.textContent = messageText;
      messageEl.className = 'wrong';
    }

    if (gameState.lives > 0 || gameMode === 'timed-analysis') {
      setTimeout(nextRound, 1800);
    }
  }

  function createChoices() {
    choicesEl.innerHTML = '';
    shapeDefs.forEach((shape, i) => {
      const cont = document.createElement('div');
      cont.className = 'choice';
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 200 200');
      svg.style.width = '70%';
      svg.style.height = '70%';
      shape.draw('#555', svg);
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = shape.name;
      cont.append(svg, label);
      cont.onclick = () => processAnswer(i, null);
      choicesEl.append(cont);
    });

    colorChoicesEl.innerHTML = '';
    colors.forEach((color, i) => {
      const cont = document.createElement('div');
      cont.className = 'choice';
      const colorBox = document.createElement('div');
      colorBox.className = 'color-box';
      colorBox.style.backgroundColor = color;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = colorNames[i];
      cont.append(colorBox, label);
      cont.onclick = () => processAnswer(null, i);
      colorChoicesEl.append(cont);
    });
  }
  
  // --- [BUG FIX] ---
  // Only show color choices in 'color-shape' mode.
  function toggleChoiceVisibility(show = false) {
      if (gameMode === 'color-shape') {
          choicesEl.style.display = show ? 'grid' : 'none';
          colorChoicesEl.style.display = show ? 'grid' : 'none';
      } else {
          choicesEl.style.display = show ? 'grid' : 'none';
          colorChoicesEl.style.display = 'none'; // Always hide color choices for other modes
      }
  }

  function toggleGameElementsVisibility() {
    if (gameMode === 'timed-analysis') {
        timerBar.style.display = 'none';
        endGameBtn.style.display = 'block';
    } else {
        timerBar.style.display = 'block';
        endGameBtn.style.display = 'none';
    }
  }
  
  function drawResponseTimeChart(data) {
    if (myChart) {
      myChart.destroy();
    }

    // --- [BUG FIX] ---
    // Replaced CSS variables with hardcoded color values for Chart.js compatibility.
    const chartTextColor = '#333'; 

    const ctx = responseTimeChartCanvas.getContext('2d');
    myChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: data.map((_, i) => `問題 ${i + 1}`),
        datasets: [{
          label: '解答時間 (ms)',
          data: data,
          borderColor: 'rgb(75, 192, 192)',
          tension: 0.4,
          fill: false,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointBackgroundColor: 'rgb(75, 192, 192)',
          pointBorderColor: '#fff',
          pointBorderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: {
            display: true,
            text: '各問題の解答時間推移',
            font: { size: 16 },
            color: chartTextColor
          },
          legend: { display: false }
        },
        scales: {
          x: {
            title: {
              display: true,
              text: '問題番号',
              color: chartTextColor
            },
            ticks: { color: chartTextColor }
          },
          y: {
            title: {
              display: true,
              text: '時間 (ms)',
              color: chartTextColor
            },
            min: 0,
            ticks: { color: chartTextColor }
          }
        }
      }
    });
  }

  // --- 初期化とイベントリスナー ---
  document.getElementById('normal-mode-btn').onclick = () => startGame('normal');
  document.getElementById('color-shape-mode-btn').onclick = () => startGame('color-shape');
  document.getElementById('hard-mode-btn').onclick = () => startGame('hard');
  document.getElementById('timed-analysis-mode-btn').onclick = () => startGame('timed-analysis');
  document.getElementById('retry-btn').onclick = () => startGame(gameMode);
  document.getElementById('back-to-menu-btn').onclick = () => showScreen('start');
  endGameBtn.onclick = gameOver;

  createChoices();
  showScreen('start');
});
</script>
</body>
</html>
