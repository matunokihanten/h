<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üî•„Ç¢„ÉÑ„ÅÑË®òÊÜ∂„ÉÅ„É£„É¨„É≥„Ç∏üî• NEO</title>
  <style>
    :root {
      --bg-color: #f0f2f5;
      --panel-bg: #fff;
      --text-color: #333;
      --primary-color: #fcbf49;
      --correct-color: #2ecc71;
      --wrong-color: #e74c3c;
      --border-color: #ddd;
      --border-hover: #333;
    }
    body {
      font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      text-align: center;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .screen {
      display: none; /* Initially hide all screens */
      width: 100%;
      max-width: 420px;
    }
    .screen.active {
      display: block;
    }
    h1 {
      margin-bottom: 5px;
      color: var(--primary-color);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    p { margin: 0 0 20px; }
    button {
      font-size: 1.2em;
      padding: 12px 30px;
      border-radius: 50px;
      border: none;
      background: var(--primary-color);
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-top: 10px; /* Added for mode selection buttons */
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 15px rgba(0,0,0,0.2);
    }
    #game-container {
      background: var(--panel-bg);
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    #scoreboard {
      font-size: 1.1em;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-around;
      gap: 10px;
    }
    #timerBar {
      width: 100%; height: 12px;
      background: var(--border-color); margin: 0 auto 20px;
      border-radius: 6px; overflow: hidden;
    }
    #timerFill {
      height: 100%;
      background: linear-gradient(90deg, var(--correct-color), var(--primary-color), var(--wrong-color));
      width: 100%;
      transition: width 0.1s linear;
    }
    #svgPanel {
      width: 180px; height: 180px;
      margin: 0 auto 10px;
      border: 4px solid var(--border-hover);
      border-radius: 12px;
      transition: transform 0.3s ease-in-out;
    }
    #question {
      font-weight: bold;
      font-size: 1.2em;
      margin: 10px 0;
      min-height: 1.5em;
    }
    #choices, #colorChoices {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 15px;
      margin-top: 15px; /* Spacing between shape and color choices */
    }
    .choice {
      aspect-ratio: 1 / 1;
      border: 2px solid var(--border-color);
      background: var(--panel-bg);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform .2s, border-color .2s;
      border-radius: 8px;
    }
    .choice:hover {
      transform: scale(1.05);
      border-color: var(--border-hover);
    }
    .choice.selected { /* Added for color selection feedback */
      border-color: var(--primary-color);
      box-shadow: 0 0 10px var(--primary-color);
      transform: scale(1.05);
    }
    .choice.disabled {
      pointer-events: none;
      opacity: 0.5;
    }
    .label { font-size: 14px; margin-top: 5px; font-weight: bold; }
    .color-box { /* Added for color choice display */
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 2px solid var(--border-color);
        box-sizing: border-box;
    }
    #message { margin-top: 15px; font-size: 1.2em; font-weight: bold; min-height: 1.5em; }
    .correct { color: var(--correct-color); }
    .wrong { color: var(--wrong-color); }
    #gameover-screen #final-score, #gameover-screen #high-score {
        font-size: 1.5em; font-weight: bold; display: block; margin: 10px 0;
    }
    /* Animations */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    @keyframes flash-correct {
      from { border-color: var(--correct-color); box-shadow: 0 0 15px var(--correct-color); }
      to { border-color: var(--border-hover); box-shadow: none; }
    }
    .shake { animation: shake 0.3s ease-in-out; }
    .flash-correct { animation: flash-correct 0.5s ease-out; }
  </style>
</head>
<body>

  <div id="main-container">
    <div id="start-screen" class="screen active">
      <h1>üî•„Ç¢„ÉÑ„ÅÑË®òÊÜ∂„ÉÅ„É£„É¨„É≥„Ç∏üî• NEO</h1>
      <p>Ê¨°„ÄÖ„Å®Ë°®Á§∫„Åï„Çå„ÇãÂõ≥ÂΩ¢„ÇíË®òÊÜ∂„Åó„ÄÅ<br>„ÄåNÂÄãÂâç„ÅÆÂõ≥ÂΩ¢„Äç„ÇíÂΩì„Å¶„Çà„ÅÜÔºÅ</p>
      <button id="normal-mode-btn">„Éé„Éº„Éû„É´„É¢„Éº„Éâ (1ÂÄãÂâç)</button>
      <button id="color-shape-mode-btn">Ëâ≤&ÂΩ¢„É¢„Éº„Éâ (Áõ¥Ââç)</button>
      <button id="hard-mode-btn">„Éè„Éº„Éâ„É¢„Éº„Éâ (NÂÄãÂâç)</button>
    </div>

    <div id="game-screen" class="screen">
      <div id="game-container">
        <div id="scoreboard">
          <span>‚ù§Ô∏è <span id="lives">3</span></span>
          <span>„Çπ„Ç≥„Ç¢: <span id="score">0</span></span>
          <span>ÈÄ£Âãù: <span id="streak">0</span></span>
          <span>Lv: <span id="level">1</span></span>
        </div>
        <div id="timerBar"><div id="timerFill"></div></div>

        <svg id="svgPanel" viewBox="0 0 200 200"></svg>
        <div id="question"></div>
        <div id="choices"></div>
        <div id="colorChoices"></div> <div id="message"></div>
      </div>
    </div>

    <div id="gameover-screen" class="screen">
        <h1>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h1>
        <div>„ÅÇ„Å™„Åü„ÅÆ„Çπ„Ç≥„Ç¢: <span id="final-score">0</span></div>
        <div>„Éè„Ç§„Çπ„Ç≥„Ç¢: <span id="high-score">0</span></div>
        <br>
        <button id="retry-btn">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶</button>
        <button id="back-to-menu-btn">„É¢„Éº„ÉâÈÅ∏Êäû„Å´Êàª„Çã</button>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // --- Âõ≥ÂΩ¢„Éá„Éº„Çø ---
  const shapeDefs = [
    { name:'„Åæ„Çã',   draw: (c, svg) => svg.innerHTML = `<circle cx="100" cy="100" r="60" fill="${c}"/>` },
    { name:'„Åó„Åã„Åè', draw: (c, svg) => svg.innerHTML = `<rect x="50" y="50" width="100" height="100" fill="${c}"/>` },
    { name:'„Åï„Çì„Åã„Åè',draw: (c, svg) => svg.innerHTML = `<polygon points="100,30 170,170 30,170" fill="${c}"/>` },
    { name:'„Åª„Åó',   draw: (c, svg) => svg.innerHTML = `<polygon points="100,10 120,80 190,80 135,125 150,195 100,155 50,195 65,125 10,80 80,80" fill="${c}"/>` },
    { name:'„Å≤„Åó', draw: (c, svg) => svg.innerHTML = `<polygon points="100,20 180,100 100,180 20,100" fill="${c}"/>` },
    { name:'„Åò„ÇÖ„ÅÜ„Åò', draw: (c, svg) => svg.innerHTML = `<rect x="80" y="30" width="40" height="140" fill="${c}"/><rect x="30" y="80" width="140" height="40" fill="${c}"/>` }
  ];
  const colors = ['#ff6666', '#66ccff', '#99ff99', '#fcbf49', '#8e44ad', '#3498db'];
  const colorNames = ['Ëµ§', 'Ê∞¥Ëâ≤', 'Á∑ë', 'ÈªÑ', 'Á¥´', 'Èùí']; // For display purposes

  // --- „Ç≤„Éº„É†Áä∂ÊÖã ---
  let gameState = {};
  let gameMode = 'hard'; // 'normal', 'hard', or 'color-shape'
  let selectedShapeIndex = -1; // For 'color-shape' mode
  let selectedColorIndex = -1; // For 'color-shape' mode

  // --- DOMË¶ÅÁ¥† ---
  const screens = {
    start: document.getElementById('start-screen'),
    game: document.getElementById('game-screen'),
    gameOver: document.getElementById('gameover-screen')
  };
  const svgPanel = document.getElementById('svgPanel');
  const choicesEl = document.getElementById('choices');
  const colorChoicesEl = document.getElementById('colorChoices'); // New
  const messageEl = document.getElementById('message');
  const questionEl = document.getElementById('question');
  const livesEl = document.getElementById('lives');
  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const levelEl = document.getElementById('level');
  const timerFill = document.getElementById('timerFill');
  const finalScoreEl = document.getElementById('final-score');
  const highScoreEl = document.getElementById('high-score');
  
  // --- „Çµ„Ç¶„É≥„Éâ ---
  let audioCtx;
  function playSound(type) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g);
    g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
    
    if (type === 'correct') {
      o.type = 'triangle';
      o.frequency.value = 880;
    } else if (type === 'wrong') {
      o.type = 'sawtooth';
      o.frequency.value = 220;
    } else { // level up
      o.type = 'sine';
      o.frequency.value = 1200;
    }
    o.start(audioCtx.currentTime);
    o.stop(audioCtx.currentTime + 0.2);
  }

  // --- ÁîªÈù¢Âàá„ÇäÊõø„Åà ---
  function showScreen(screenId) {
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens[screenId].classList.add('active');
  }

  // --- „Éè„Ç§„Çπ„Ç≥„Ç¢Âá¶ÁêÜ ---
  function loadHighScore(mode) {
    return localStorage.getItem('memoryGameHighScore_' + mode) || 0;
  }
  function saveHighScore(score, mode) {
    const highScore = loadHighScore(mode);
    if (score > highScore) {
      localStorage.setItem('memoryGameHighScore_' + mode, score);
    }
  }

  // --- „Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ ---
  function resetGameState() {
    gameState = {
      history: [],
      score: 0,
      streak: 0,
      level: 1,
      lives: 3,
      nBack: (gameMode === 'hard' ? 1 : 1), // N-back starts at 1 for normal/color-shape, hard mode increases it
      roundTime: 4000,
      answerAllowed: false,
      timerInterval: null
    };
    selectedShapeIndex = -1;
    selectedColorIndex = -1;
    updateUI();
    toggleChoiceVisibility(); // Ensure correct choices are visible/hidden
  }

  function startGame(mode) {
    gameMode = mode;
    resetGameState();
    showScreen('game');
    setTimeout(nextRound, 500); // Wait a bit before starting
  }

  function gameOver() {
    gameState.answerAllowed = false;
    clearInterval(gameState.timerInterval);
    saveHighScore(gameState.score, gameMode);
    finalScoreEl.textContent = gameState.score;
    highScoreEl.textContent = loadHighScore(gameMode);
    showScreen('gameOver');
  }

  function updateScore(correct) {
    if (correct) {
      gameState.streak++;
      gameState.score += 10 * gameState.streak * gameState.nBack; // nBack might be 1 for normal/color-shape
      // Level Up logic based on mode
      if (gameMode === 'hard') {
        if (gameState.streak > 0 && gameState.streak % 4 === 0) {
          gameState.level++;
          playSound('level-up');
          gameState.roundTime = Math.max(1500, gameState.roundTime - 400);
          if (gameState.level >= 5 && gameState.level % 4 === 1) {
            gameState.nBack = Math.min(3, gameState.nBack + 1); // Max N-Back is 3
          }
        }
      } else { // Normal and Color & Shape modes
          if (gameState.streak > 0 && gameState.streak % 5 === 0) { // Slightly different progression for simpler modes
              gameState.level++;
              playSound('level-up');
              gameState.roundTime = Math.max(2000, gameState.roundTime - 200);
          }
      }
    } else {
      gameState.streak = 0;
      gameState.lives--;
      svgPanel.parentElement.classList.add('shake');
      setTimeout(() => svgPanel.parentElement.classList.remove('shake'), 300);
      if (gameState.lives <= 0) {
        setTimeout(gameOver, 500);
        return;
      }
    }
    updateUI();
  }

  function updateUI() {
    scoreEl.textContent = gameState.score;
    streakEl.textContent = gameState.streak;
    levelEl.textContent = gameState.level;
    livesEl.textContent = gameState.lives;
  }

  function nextRound() {
    messageEl.textContent = '';
    messageEl.className = '';
    choicesEl.querySelectorAll('.choice').forEach(c => c.classList.remove('disabled', 'selected'));
    colorChoicesEl.querySelectorAll('.choice').forEach(c => c.classList.remove('disabled', 'selected'));
    selectedShapeIndex = -1;
    selectedColorIndex = -1;

    let newShapeIndex;
    let newColorIndex;
    
    // Ensure new shape is different from the previous one
    do {
      newShapeIndex = Math.floor(Math.random() * shapeDefs.length);
    } while (gameState.history.length > 0 &&
             newShapeIndex === gameState.history[0].shapeIndex);
    
    newColorIndex = Math.floor(Math.random() * colors.length);

    gameState.history.unshift({ shapeIndex: newShapeIndex, colorIndex: newColorIndex });
    
    // Keep history trimmed to avoid excessive memory usage for very long games
    // For nBack modes, keep max N-back + 1 to ensure target is always in history
    const maxHistoryLength = (gameMode === 'hard' ? 4 : 2); // Max nBack is 3, plus current. For others, just previous + current.
    if (gameState.history.length > maxHistoryLength) {
        gameState.history.pop();
    }

    shapeDefs[newShapeIndex].draw(colors[newColorIndex], svgPanel);
    svgPanel.style.transform = 'scale(1.05)';
    setTimeout(() => svgPanel.style.transform = 'scale(1)', 200);

    const currentNBack = (gameMode === 'hard' ? gameState.nBack : 1);

    if (gameState.history.length > currentNBack) {
      if (gameMode === 'color-shape') {
        questionEl.textContent = `üî• Áõ¥Ââç„ÅÆ„ÄåÂΩ¢„Å®Ëâ≤„Äç„ÅØÔºü`;
      } else {
        questionEl.textContent = `üî• ${currentNBack}ÂÄãÂâç„ÅÆÂΩ¢„ÅØÔºü`;
      }
      startRoundTimer();
      toggleChoiceVisibility(true); // Show choices when it's time to answer
    } else {
      questionEl.textContent = 'Ë¶ö„Åà„Å¶„Å≠ÔºÅ';
      toggleChoiceVisibility(false); // Hide choices during memory phase
      setTimeout(nextRound, 1000);
    }
  }

  function startRoundTimer() {
    gameState.answerAllowed = true;
    let timeLeft = gameState.roundTime;
    clearInterval(gameState.timerInterval);
    timerFill.style.transition = 'none'; 
    timerFill.style.width = '100%';
    
    timerFill.offsetHeight; 
    timerFill.style.transition = `width ${gameState.roundTime / 1000}s linear`;
    timerFill.style.width = '0%';
    
    gameState.timerInterval = setTimeout(() => {
      if(gameState.answerAllowed) {
        processAnswer(null, null); 
      }
    }, gameState.roundTime);
  }

  function processAnswer(shapeIdx, colorIdx) {
    if (!gameState.answerAllowed && gameMode !== 'color-shape') return; // Allow partial answers in color-shape mode
    
    if (gameMode === 'color-shape') {
      if (shapeIdx !== null) selectedShapeIndex = shapeIdx;
      if (colorIdx !== null) selectedColorIndex = colorIdx;

      // Highlight selected shape/color
      choicesEl.querySelectorAll('.choice').forEach((c, i) => {
        c.classList.toggle('selected', i === selectedShapeIndex);
      });
      colorChoicesEl.querySelectorAll('.choice').forEach((c, i) => {
        c.classList.toggle('selected', i === selectedColorIndex);
      });

      if (selectedShapeIndex === -1 || selectedColorIndex === -1) {
        // Not both selected yet, don't finalize answer or clear timer
        return;
      }
    } else { // Normal or Hard mode
        if (!gameState.answerAllowed) return; // Disallow answer if not allowed
        selectedShapeIndex = shapeIdx; // Only shape matters
    }

    gameState.answerAllowed = false;
    clearTimeout(gameState.timerInterval);

    const currentNBack = (gameMode === 'hard' ? gameState.nBack : 1);
    const correctTarget = gameState.history[currentNBack];
    
    let isCorrect = false;
    if (gameMode === 'color-shape') {
      isCorrect = (selectedShapeIndex == correctTarget.shapeIndex && selectedColorIndex == correctTarget.colorIndex);
    } else { // Normal or Hard
      isCorrect = (selectedShapeIndex == correctTarget.shapeIndex);
    }

    playSound(isCorrect ? 'correct' : 'wrong');
    updateScore(isCorrect);
    
    choicesEl.querySelectorAll('.choice').forEach(c => c.classList.add('disabled'));
    colorChoicesEl.querySelectorAll('.choice').forEach(c => c.classList.add('disabled'));


    if (shapeIdx === null && colorIdx === null) { // Time out
      let messageText = `‚è∞ ÊôÇÈñìÂàá„Çå‚Ä¶ Ê≠£Ëß£„ÅØ„Äé${shapeDefs[correctTarget.shapeIndex].name}„Äè`;
      if (gameMode === 'color-shape') {
        messageText += `„ÅÆ„Äé${colorNames[correctTarget.colorIndex]}„Äè`;
      }
      messageEl.textContent = messageText;
      messageEl.className = 'wrong';
    } else if (isCorrect) {
      messageEl.textContent = `‚úÖ Ê≠£Ëß£ÔºÅ`;
      messageEl.className = 'correct';
      svgPanel.classList.add('flash-correct');
      setTimeout(()=> svgPanel.classList.remove('flash-correct'), 500);
    } else {
      let messageText = `‚ùå ‰∏çÊ≠£Ëß£‚Ä¶ Ê≠£Ëß£„ÅØ„Äé${shapeDefs[correctTarget.shapeIndex].name}„Äè`;
      if (gameMode === 'color-shape') {
        messageText += `„ÅÆ„Äé${colorNames[correctTarget.colorIndex]}„Äè`;
      }
      messageEl.textContent = messageText;
      messageEl.className = 'wrong';
    }

    if (gameState.lives > 0) {
      setTimeout(nextRound, 1800);
    }
  }

  function createChoices() {
    choicesEl.innerHTML = '';
    shapeDefs.forEach((shape, i) => {
      const cont = document.createElement('div');
      cont.className = 'choice';
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 200 200');
      svg.style.width = '70%';
      svg.style.height = '70%';
      shape.draw('#555', svg);
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = shape.name;
      cont.append(svg, label);
      cont.onclick = () => processAnswer(i, null); // Pass null for color initially
      choicesEl.append(cont);
    });

    colorChoicesEl.innerHTML = '';
    colors.forEach((color, i) => {
      const cont = document.createElement('div');
      cont.className = 'choice';
      const colorBox = document.createElement('div');
      colorBox.className = 'color-box';
      colorBox.style.backgroundColor = color;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = colorNames[i];
      cont.append(colorBox, label);
      cont.onclick = () => processAnswer(null, i); // Pass null for shape initially
      colorChoicesEl.append(cont);
    });
  }

  function toggleChoiceVisibility(show = false) {
      if (gameMode === 'color-shape') {
          choicesEl.style.display = show ? 'grid' : 'none';
          colorChoicesEl.style.display = show ? 'grid' : 'none';
      } else {
          choicesEl.style.display = show ? 'grid' : 'none';
          colorChoicesEl.style.display = 'none'; // Always hide color choices for other modes
      }
  }

  // --- ÂàùÊúüÂåñ„Å®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº ---
  document.getElementById('normal-mode-btn').onclick = () => startGame('normal');
  document.getElementById('color-shape-mode-btn').onclick = () => startGame('color-shape');
  document.getElementById('hard-mode-btn').onclick = () => startGame('hard');
  document.getElementById('retry-btn').onclick = () => startGame(gameMode); // Retry with current mode
  document.getElementById('back-to-menu-btn').onclick = () => showScreen('start');

  createChoices();
  showScreen('start');
});
</script>
</body>
</html>
