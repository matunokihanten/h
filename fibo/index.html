<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>フィボマージパズル - スマホ対応＆フィボナッチ一覧付き</title>
  <style>
    body {
      background: #faf8ef;
      font-family: "Helvetica Neue", Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    #score {
      margin-bottom: 10px;
      font-size: 18px;
      font-weight: bold;
    }
    #instructions {
      font-size: 16px;
      margin-bottom: 20px;
      text-align: center;
    }
    /* 盤面コンテナ */
    #game-container {
      width: 420px;
      height: 420px;
      background: #bbada0;
      border-radius: 6px;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-gap: 10px;
      position: relative;
    }
    /* 各セル */
    .tile {
      width: 100%;
      height: 100%;
      background: #eee4da;
      border-radius: 3px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      font-weight: bold;
      color: #776e65;
      transition: background-color 0.3s, transform 0.3s;
    }
    .tile.empty { background: transparent; }
    /* 値に応じた色分け */
    .tile-1   { background: #ede4c9; }
    .tile-2   { background: #f2c649; }
    .tile-3   { background: #f2b179; }
    .tile-5   { background: #f59563; }
    .tile-8   { background: #f67c5f; }
    .tile-13  { background: #f65e3b; }
    .tile-21  { background: #edcf72; }
    .tile:not([class*="tile-"]) { background: #3c3a32; color: #f9f6f2; }
    
    /* ポップインアニメーション（タイル生成時） */
    @keyframes popIn {
      0% { transform: scale(0); opacity: 0; }
      70% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); }
    }
    .tile.new {
      animation: popIn 0.3s ease-out;
    }
    
    /* スマホ用の十字キーコントロール */
    #controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .control-row {
      display: flex;
      justify-content: center;
    }
    .control-btn {
      width: 60px;
      height: 60px;
      margin: 5px;
      font-size: 24px;
      font-weight: bold;
      border: none;
      border-radius: 10px;
      background: #8f7a66;
      color: white;
      box-shadow: 0px 3px 0px #776e65;
      user-select: none;
    }
    
    /* フィボナッチ一覧用のスタイル（5列×5行） */
    #fib-list-container {
      margin-top: 30px;
      width: 420px;
    }
    #fib-list-container h2 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 18px;
    }
    #fib-list-container table {
      width: 100%;
      border-collapse: collapse;
    }
    #fib-list-container table, #fib-list-container th, #fib-list-container td {
      border: 1px solid #ccc;
    }
    #fib-list-container th, #fib-list-container td {
      padding: 4px;
      text-align: center;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>フィボマージパズル</h1>
  <div id="score">スコア: 0  最大フィボナッチ数: 0</div>
  <div id="instructions">
    遊び方：キーボードの矢印キーまたは下の十字キーを使ってタイルを動かしてください。
  </div>
  <div id="game-container"></div>
  
  <!-- スマホ用コントロール（十字キー） -->
  <div id="controls">
    <button id="up" class="control-btn">↑</button>
    <div class="control-row">
      <button id="left" class="control-btn">←</button>
      <button id="down" class="control-btn">↓</button>
      <button id="right" class="control-btn">→</button>
    </div>
  </div>
  
  <!-- フィボナッチ数一覧（5列×5行、合計25個） -->
  <div id="fib-list-container">
    <h2>フィボナッチ数一覧 (25個)</h2>
    <div id="fib-list"></div>
  </div>

  <script>
    // ゲーム盤面は4x4の2次元配列で管理
    let board;
    // ゲーム用のフィボナッチ数列（マージ用、今回は一部のみ使用）
    const fibs = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
    let score = 0;
    // サウンド読み込み（ファイルがなければ下記行をコメントアウトしてください）
    const mergeSound = new Audio('sounds/merge.mp3');
    const spawnSound = new Audio('sounds/spawn.mp3');

    document.addEventListener('DOMContentLoaded', function() {
      initGame();
      document.addEventListener('keydown', handleKey);
      // スマホ用ボタンのクリックイベント設定
      document.getElementById('up').addEventListener('click', () => { move('up'); });
      document.getElementById('left').addEventListener('click', () => { move('left'); });
      document.getElementById('down').addEventListener('click', () => { move('down'); });
      document.getElementById('right').addEventListener('click', () => { move('right'); });
      // フィボナッチ数一覧を生成（25個、5列×5行）
      generateFibonacciList();
    });

    // ゲーム初期化
    function initGame() {
      board = [
        [null, null, null, null],
        [null, null, null, null],
        [null, null, null, null],
        [null, null, null, null]
      ];
      score = 0;
      createBoardUI();
      spawnTile();
      spawnTile();
      updateUI();
    }

    // 盤面のセルをHTML上に生成
    function createBoardUI() {
      const container = document.getElementById('game-container');
      container.innerHTML = '';
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          let cell = document.createElement('div');
          cell.className = "tile empty";
          cell.id = "cell-" + r + "-" + c;
          container.appendChild(cell);
        }
      }
    }

    // 盤面状態とアニメーションの更新
    function updateUI() {
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          let cell = document.getElementById("cell-" + r + "-" + c);
          let value = board[r][c];
          cell.textContent = value ? value : '';
          if (value) {
            cell.className = "tile tile-" + value + " new";
          } else {
            cell.className = "tile empty";
          }
        }
      }
      updateScore();
    }

    // スコアと最大フィボナッチ数の更新
    function updateScore() {
      let maxTile = 0;
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (board[r][c] && board[r][c] > maxTile) {
            maxTile = board[r][c];
          }
        }
      }
      document.getElementById("score").textContent =
        "スコア: " + score + "  最大フィボナッチ数: " + maxTile;
    }

    // 空セルに新規タイル出現（90%で1、10%で2）
    function spawnTile() {
      let emptyCells = [];
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (board[r][c] === null) emptyCells.push({ r, c });
        }
      }
      if (emptyCells.length === 0) return;
      let randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      let newValue = Math.random() < 0.9 ? 1 : 2;
      board[randomCell.r][randomCell.c] = newValue;
    }

    // 2つのタイルがマージ可能か（1同士、またはフィボナッチ数列上で隣接しているか）
    function canMerge(a, b) {
      if (a === null || b === null) return false;
      if (a === 1 && b === 1) return true;
      let idxA = fibs.indexOf(a);
      let idxB = fibs.indexOf(b);
      if (idxA === -1 || idxB === -1) return false;
      return Math.abs(idxA - idxB) === 1;
    }

    // タイルのマージ処理（合体後、次のフィボナッチ数へ）
    function merge(a, b) {
      if (a === 1 && b === 1) {
        score += 2;
        return 2;
      }
      let larger = Math.max(a, b);
      let index = fibs.indexOf(larger);
      if (index !== -1 && index + 1 < fibs.length) {
        const newVal = fibs[index + 1];
        score += newVal;
        return newVal;
      }
      return larger;
    }

    // 1行または1列のスライド＆マージ処理
    function slideAndMergeRow(row) {
      let filtered = row.filter(val => val !== null);
      let merged = [];
      let i = 0;
      while (i < filtered.length) {
        if (i < filtered.length - 1 && canMerge(filtered[i], filtered[i + 1])) {
          merged.push(merge(filtered[i], filtered[i + 1]));
          i += 2;
        } else {
          merged.push(filtered[i]);
          i++;
        }
      }
      while (merged.length < 4) merged.push(null);
      return merged;
    }

    // 指定方向に盤面移動を実行
    function move(direction) {
      const oldBoard = JSON.stringify(board);
      let mergedOccurred = false;
      
      if (direction === 'left') {
        for (let r = 0; r < 4; r++) {
          const originalRow = board[r].slice();
          const newRow = slideAndMergeRow(board[r]);
          if (JSON.stringify(originalRow) !== JSON.stringify(newRow))
            mergedOccurred = true;
          board[r] = newRow;
        }
      } else if (direction === 'right') {
        for (let r = 0; r < 4; r++) {
          const originalRow = board[r].slice();
          const reversedRow = board[r].slice().reverse();
          let mergedRow = slideAndMergeRow(reversedRow);
          mergedRow = mergedRow.reverse();
          if (JSON.stringify(originalRow) !== JSON.stringify(mergedRow))
            mergedOccurred = true;
          board[r] = mergedRow;
        }
      } else if (direction === 'up') {
        for (let c = 0; c < 4; c++) {
          let col = [];
          for (let r = 0; r < 4; r++) {
            col.push(board[r][c]);
          }
          const originalCol = col.slice();
          const mergedCol = slideAndMergeRow(col);
          if (JSON.stringify(originalCol) !== JSON.stringify(mergedCol))
            mergedOccurred = true;
          for (let r = 0; r < 4; r++) {
            board[r][c] = mergedCol[r];
          }
        }
      } else if (direction === 'down') {
        for (let c = 0; c < 4; c++) {
          let col = [];
          for (let r = 0; r < 4; r++) {
            col.push(board[r][c]);
          }
          const originalCol = col.slice();
          col.reverse();
          let mergedCol = slideAndMergeRow(col);
          mergedCol.reverse();
          if (JSON.stringify(originalCol) !== JSON.stringify(mergedCol))
            mergedOccurred = true;
          for (let r = 0; r < 4; r++) {
            board[r][c] = mergedCol[r];
          }
        }
      }
      
      if (JSON.stringify(board) !== oldBoard) {
        if (mergedOccurred) {
          // サウンド再生（ファイルがなければコメントアウト）
          mergeSound.play();
        }
        spawnTile();
        spawnSound.play();
        updateUI();
        if (checkGameOver()) {
          setTimeout(() => { alert("Game Over!"); }, 300);
        }
      }
    }

    // ゲームオーバーチェック：空セルがなく隣接でマージ可能なタイルも無い場合
    function checkGameOver() {
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (board[r][c] === null) return false;
          if (r < 3 && canMerge(board[r][c], board[r+1][c])) return false;
          if (c < 3 && canMerge(board[r][c], board[r][c+1])) return false;
        }
      }
      return true;
    }

    // キー操作のハンドラ（矢印キー対応）
    function handleKey(e) {
      switch (e.key) {
        case 'ArrowLeft':
          move('left');
          break;
        case 'ArrowRight':
          move('right');
          break;
        case 'ArrowUp':
          move('up');
          break;
        case 'ArrowDown':
          move('down');
          break;
      }
    }
    
    // 25個のフィボナッチ数（標準的に 1, 1, 2, 3, 5, ...）を生成する
    function generateFibonacci(n) {
      let fib = [];
      fib[0] = 1;
      fib[1] = 1;
      for (let i = 2; i < n; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];
      }
      return fib;
    }
    
    // フィボナッチ数一覧（5列×5行）をHTMLに出力する
    function generateFibonacciList() {
      const fibNumbers = generateFibonacci(25);
      let html = '<table>';
      for (let row = 0; row < 5; row++) {
        html += '<tr>';
        for (let col = 0; col < 5; col++) {
          const index = row * 5 + col;
          html += '<td>' + fibNumbers[index] + '</td>';
        }
        html += '</tr>';
      }
      html += '</table>';
      document.getElementById('fib-list').innerHTML = html;
    }
  </script>
</body>
</html>