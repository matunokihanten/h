<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ディレクトリ構成ZIPツール</title>
    <!-- Tailwind CSSを読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZipライブラリを読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* 簡単なスタイル調整 */
        body {
            font-family: 'Inter', sans-serif;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-8 font-[Noto Sans JP]">
    <div class="container bg-white rounded-2xl shadow-xl p-6 sm:p-10">
        <header class="text-center mb-10">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">ディレクトリ構成ZIPツール</h1>
            <p class="mt-3 text-gray-600">テキストからZIPを生成したり、ZIPから構成を読み込んだりできます。</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <!-- 左側: テキストからZIPを生成 -->
            <div class="flex flex-col bg-gray-50 p-6 rounded-xl border border-gray-200">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800">1. テキストからZIPを生成</h2>
                <p class="mb-4 text-gray-500">下のテキストエリアにディレクトリ構成を入力し、「ZIP生成」ボタンを押してください。</p>
                <textarea id="structureInput" class="w-full h-80 p-4 border border-gray-300 rounded-lg resize-y focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="my-project/
├── src/
│   ├── index.js
│   └── style.css
├── public/
│   └── index.html
└── package.json"></textarea>
                <button id="generateBtn" class="mt-4 w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform transform hover:scale-105 shadow-md">
                    ZIPを生成してダウンロード
                </button>
                <div id="generateMessage" class="mt-3 text-sm text-green-600"></div>
            </div>

            <!-- 右側: ZIPから構成を読み込み -->
            <div class="flex flex-col bg-gray-50 p-6 rounded-xl border border-gray-200">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800">2. ZIPから構成を読み込み</h2>
                <p class="mb-4 text-gray-500">ZIPファイルを選択すると、下のエリアにディレクトリ構成が表示されます。</p>
                <div class="relative">
                    <input type="file" id="zipInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" accept=".zip">
                    <label for="zipInput" class="w-full flex justify-center items-center bg-white text-blue-600 font-semibold py-3 px-4 rounded-lg border-2 border-dashed border-blue-400 hover:bg-blue-50 cursor-pointer transition">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                        ZIPファイルを選択
                    </label>
                </div>
                <pre id="structureOutput" class="w-full h-80 mt-4 p-4 border bg-white border-gray-300 rounded-lg overflow-auto whitespace-pre-wrap break-words text-sm"></pre>
                <div id="readMessage" class="mt-3 text-sm text-red-600"></div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM要素の取得 ---
        const structureInput = document.getElementById('structureInput');
        const generateBtn = document.getElementById('generateBtn');
        const generateMessage = document.getElementById('generateMessage');
        const zipInput = document.getElementById('zipInput');
        const structureOutput = document.getElementById('structureOutput');
        const readMessage = document.getElementById('readMessage');

        // --- ZIP生成機能 (バグ修正済み) ---
        generateBtn.addEventListener('click', () => {
            const text = structureInput.value;
            if (!text.trim()) {
                generateMessage.textContent = 'テキストが入力されていません。';
                generateMessage.className = 'mt-3 text-sm text-red-600';
                return;
            }

            generateMessage.textContent = 'ZIPファイルを生成中...';
            generateMessage.className = 'mt-3 text-sm text-blue-600';

            try {
                const zip = new JSZip();
                const lines = text.split('\n');
                // pathStackは現在のディレクトリ階層を保持します
                const pathStack = [];

                lines.forEach(line => {
                    // Webからコピーした際などに含まれる特殊な空白文字を正規化し、行末の空白を削除
                    const cleanedLine = line.replace(/[\u00A0\u202F\u205F\u3000]/g, ' ').trimEnd();
                    if (cleanedLine.trim() === '') return;

                    // 行から構造部分（インデントや接続詞）と名前部分を分離
                    const lineMatch = cleanedLine.match(/^([\s│├└─]*)(.*)$/);
                    if (!lineMatch) return;

                    const name = lineMatch[2].trim();
                    if (!name) return;

                    // 階層の深さ（depth）を名前の開始位置から算出。これにより、より正確に階層を判断
                    // 1階層あたり約4文字のインデント幅と仮定
                    const depth = Math.round(cleanedLine.indexOf(name) / 4);

                    // 現在の行の階層に合わせて、pathStackを調整（浅い階層に戻る場合）
                    while (depth < pathStack.length) {
                        pathStack.pop();
                    }

                    const isDirectory = name.endsWith('/');
                    const cleanName = isDirectory ? name.slice(0, -1) : name;

                    // 現在のファイル/フォルダのフルパスを生成
                    const currentPath = pathStack.join('/');
                    const fullPath = currentPath ? `${currentPath}/${cleanName}` : cleanName;

                    if (isDirectory) {
                        zip.folder(fullPath);
                        pathStack.push(cleanName); // ディレクトリの場合、次の階層としてスタックに追加
                    } else {
                        zip.file(fullPath, ''); // ファイルは空の内容で作成
                    }
                });

                // ZIPファイルを生成してダウンロード
                zip.generateAsync({ type: "blob" })
                    .then(function(content) {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(content);
                        link.download = "structure.zip";
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href); // メモリリークを防ぐ
                        generateMessage.textContent = 'ZIPファイルの生成が完了しました！';
                        generateMessage.className = 'mt-3 text-sm text-green-600';
                    });

            } catch (error) {
                console.error("ZIP generation error:", error);
                generateMessage.textContent = 'ZIPファイルの生成に失敗しました。入力形式を確認してください。';
                generateMessage.className = 'mt-3 text-sm text-red-600';
            }
        });

        // --- ZIP読み込み機能 ---
        zipInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            readMessage.textContent = '';
            structureOutput.textContent = 'ZIPファイルを読み込み中...';

            const reader = new FileReader();
            reader.onload = function(e) {
                JSZip.loadAsync(e.target.result)
                    .then(function(zip) {
                        // フォルダもパスとして含めるためにフィルタリング
                        const filePaths = Object.keys(zip.files).filter(path => !path.startsWith('__MACOSX'));
                        if (filePaths.length === 0) {
                            structureOutput.textContent = 'ZIPファイルは空か、対応していないファイルです。';
                            return;
                        }
                        const tree = buildTree(filePaths);
                        structureOutput.textContent = formatTree(tree);
                    })
                    .catch(function(err) {
                        console.error("ZIP reading error:", err);
                        structureOutput.textContent = '';
                        readMessage.textContent = 'ZIPファイルの読み込みに失敗しました。ファイルが破損している可能性があります。';
                    });
            };
            reader.readAsArrayBuffer(file);
        });

        /**
         * ファイルパスのリストからツリー構造のオブジェクトを生成するヘルパー関数
         * @param {string[]} paths - ファイルパスの配列
         * @returns {object} - ツリー構造のオブジェクト
         */
        function buildTree(paths) {
            const tree = {};
            // パスをソートして、親ディレクトリが先に処理されるようにする
            paths.sort();
            paths.forEach(path => {
                // 末尾の/を削除して、ファイルとディレクトリを統一的に扱う
                const cleanPath = path.endsWith('/') ? path.slice(0, -1) : path;
                if (!cleanPath) return;

                const parts = cleanPath.split('/');
                let currentLevel = tree;
                parts.forEach((part, index) => {
                    const isLastPart = index === parts.length - 1;
                    const isDirectoryInZip = path.endsWith('/');

                    if (!currentLevel[part]) {
                        // パスの最後で、かつZIP内でディレクトリとして定義されている場合、または途中のパスの場合
                        if ((isLastPart && isDirectoryInZip) || !isLastPart) {
                            currentLevel[part] = {};
                        } else {
                            currentLevel[part] = null; // ファイル
                        }
                    }
                    if (typeof currentLevel[part] === 'object' && currentLevel[part] !== null) {
                        currentLevel = currentLevel[part];
                    }
                });
            });
            return tree;
        }

        /**
         * ツリー構造のオブジェクトを整形されたテキストに変換するヘルパー関数
         * @param {object} node - ツリー構造のノード
         * @param {string} prefix - インデント用の接頭辞
         * @returns {string} - 整形されたツリーテキスト
         */
        function formatTree(node, prefix = '') {
            let result = '';
            const entries = Object.entries(node);
            entries.forEach(([key, value], index) => {
                const isLast = index === entries.length - 1;
                const connector = isLast ? '└── ' : '├── ';
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                
                const isDirectory = value !== null && typeof value === 'object';
                const displayName = isDirectory ? `${key}/` : key;
                
                result += prefix + connector + displayName + '\n';

                if (isDirectory) {
                    result += formatTree(value, newPrefix);
                }
            });
            return result;
        }

    </script>
</body>
</html>
