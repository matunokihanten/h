<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LinkMaster Infinity - 無限進化パズル</title>
  <style>
    /* Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@300;400;700&display=swap');

    /* --- 基本設定とリセット --- */
    :root {
      --bg-gradient: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%);
      --primary-glow: #00f5ff;
      --secondary-glow: #ff00ff;
      --success-glow: #00ff80;
      --warning-glow: #ffd700;
      --danger-glow: #ff4d4d;
      --text-color: #ffffff;
      --text-muted: #a0a0a0;
      --panel-bg: rgba(22, 33, 62, 0.85);
      --border-color: rgba(0, 245, 255, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Noto Sans JP', 'Orbitron', monospace;
      background: var(--bg-gradient);
      color: var(--text-color);
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    /* --- 背景演出 --- */
    .background-stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .star {
      position: absolute;
      background: var(--text-color);
      border-radius: 50%;
      animation: twinkle 3s infinite;
    }

    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    /* --- ゲーム全体コンテナ --- */
    .game-world {
        width: 100%;
        height: 100vh;
        max-width: 1200px;
        max-height: 900px;
        display: flex;
        flex-direction: column;
        padding: 20px;
    }

    /* --- ヘッダー --- */
    .game-header {
      margin-bottom: 15px;
    }

    .game-title {
      font-family: 'Orbitron', monospace;
      font-size: 3em;
      font-weight: 900;
      background: linear-gradient(45deg, var(--primary-glow), var(--secondary-glow), #ffff00);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px var(--primary-glow);
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { filter: drop-shadow(0 0 15px var(--primary-glow)); }
      to { filter: drop-shadow(0 0 30px var(--secondary-glow)); }
    }

    /* --- メインコンテンツエリア --- */
    .main-content {
        flex-grow: 1;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    
    #gameCanvas {
      border-radius: 20px;
      background: rgba(0,0,0,0.2);
      border: 2px solid var(--border-color);
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.2);
      cursor: crosshair;
      max-width: 100%;
      max-height: 100%;
      aspect-ratio: 4 / 3;
    }

    /* --- UIパネル --- */
    .ui-panel {
        display: flex;
        justify-content: space-around;
        align-items: center;
        gap: 15px;
        margin-bottom: 15px;
        flex-wrap: wrap;
    }

    .stat-item {
      background: var(--panel-bg);
      backdrop-filter: blur(5px);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 5px 15px;
      flex-grow: 1;
      min-width: 120px;
    }
    .stat-label { font-size: 0.9em; color: var(--text-muted); }
    .stat-value { font-family: 'Orbitron', monospace; font-size: 1.6em; font-weight: 700; color: var(--primary-glow); }

    /* --- コントロールボタン --- */
    .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
    }
    
    .btn {
      padding: 12px 25px;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1em;
      border: 1px solid transparent;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      color: var(--text-color);
    }
    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .btn::before {
      content: '';
      position: absolute;
      top: 0; left: -100%;
      width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s ease;
    }
    .btn:hover:not(:disabled)::before { left: 100%; }
    .btn:hover:not(:disabled) { transform: translateY(-3px); }

    .btn-primary { background: linear-gradient(45deg, #00A8FF, #0055FF); box-shadow: 0 5px 20px rgba(0, 168, 255, 0.3); }
    .btn-secondary { background: linear-gradient(45deg, var(--secondary-glow), #8000ff); box-shadow: 0 5px 20px rgba(255, 0, 255, 0.3); }
    .btn-success { background: linear-gradient(45deg, var(--success-glow), #00c957); box-shadow: 0 5px 20px rgba(0, 255, 128, 0.3); color: #0c0c0c; }
    .btn-warning { background: linear-gradient(45deg, var(--warning-glow), #ff8c00); box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3); color: #0c0c0c; }
    .btn-danger { background: linear-gradient(45deg, var(--danger-glow), #cc0000); box-shadow: 0 5px 20px rgba(255, 77, 77, 0.4); }

    /* --- モーダル共通 --- */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    .modal-content {
      background: var(--panel-bg);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      padding: 30px 40px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 0 50px rgba(0, 245, 255, 0.3);
      transform: scale(0.9);
      transition: all 0.3s ease;
    }
    .modal-overlay.visible .modal-content {
        transform: scale(1);
    }
    .modal-title { font-family: 'Orbitron', monospace; font-size: 2.2em; margin-bottom: 20px; color: var(--primary-glow); }
    .modal-body { font-size: 1.1em; line-height: 1.6; margin-bottom: 30px; }
    .modal-actions { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
    
    .result-stats { font-size: 1.2em; }
    .result-stars { font-size: 3em; color: var(--warning-glow); letter-spacing: 0.2em; text-shadow: 0 0 10px var(--warning-glow); }
    
    #challenge-selection {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
    }
    
    /* --- レスポンシブ対応 --- */
    @media (max-width: 768px) {
      .game-world { padding: 10px; }
      .game-title { font-size: 2em; }
      .ui-panel { justify-content: center; }
      .stat-item { padding: 5px 10px; min-width: 100px; }
      .stat-label { font-size: 0.8em; }
      .stat-value { font-size: 1.3em; }
      .btn { padding: 10px 20px; font-size: 0.9em; }
      .modal-content { padding: 20px; }
      .modal-title { font-size: 1.8em; }
    }
  </style>
</head>
<body>

  <div class="background-stars"></div>

  <div class="game-world">
    <header class="game-header">
      <h1 class="game-title">LinkMaster Infinity</h1>
    </header>

    <div class="ui-panel">
      <div class="stat-item">
        <div class="stat-label" id="ui-level-label">DIFFICULTY</div>
        <div class="stat-value" id="ui-level">1</div>
      </div>
      <div class="stat-item">
        <div class="stat-label" id="ui-score-label">SCORE</div>
        <div class="stat-value" id="ui-score">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">HIGH SCORE</div>
        <div class="stat-value" id="ui-highscore">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">TIME</div>
        <div class="stat-value" id="ui-timer">0:00</div>
      </div>
    </div>
    
    <main class="main-content">
      <canvas id="gameCanvas"></canvas>
    </main>

    <footer class="controls">
      <button class="btn btn-primary" id="btn-reset">RESET</button>
      <button class="btn btn-warning" id="btn-pause">PAUSE</button>
      <button class="btn btn-success" id="btn-settings">SETTINGS</button>
    </footer>
  </div>

  <div class="modal-overlay visible" id="start-screen">
    <div class="modal-content">
      <h2 class="modal-title">Welcome!</h2>
      <div class="modal-body">
        <p>Select a game mode to begin.</p>
      </div>
      <div class="modal-actions">
        <button class="btn btn-primary" id="btn-start-endless">Endless Mode</button>
        <button class="btn btn-secondary" id="btn-start-timeattack">Time Attack</button>
        <button class="btn btn-danger" id="btn-start-challenge">Challenge</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="challenge-modal">
    <div class="modal-content">
      <h2 class="modal-title">Challenge Mode</h2>
      <div class="modal-body" id="challenge-selection">
         </div>
      <div class="modal-actions">
        <button class="btn btn-warning" id="btn-challenge-back">BACK</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="pause-modal">
    <div class="modal-content">
      <h2 class="modal-title">Paused</h2>
      <div class="modal-actions">
        <button class="btn btn-primary" id="btn-resume">RESUME</button>
        <button class="btn btn-warning" id="btn-quit">QUIT</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="settings-modal">
    <div class="modal-content">
        <h2 class="modal-title">Settings</h2>
        <div class="modal-body">
            <div class="settings-row" style="display:flex; justify-content: space-between; align-items: center;">
                <label for="volume-slider" style="font-size: 1.2em;">Volume</label>
                <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5">
            </div>
        </div>
        <div class="modal-actions">
            <button class="btn btn-primary" id="btn-settings-close">CLOSE</button>
        </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="result-modal">
    <div class="modal-content">
        <h2 class="modal-title" id="result-title">Level Complete!</h2>
        <div class="modal-body">
            <div class="result-stars" id="result-stars"></div>
            <div class="result-stats">
                <p>Time: <span id="result-time"></span></p>
                <p>Score: <span id="result-score"></span></p>
            </div>
        </div>
        <div class="modal-actions">
            <button class="btn btn-success" id="btn-next-level">NEXT</button>
            <button class="btn btn-primary" id="btn-retry">RETRY</button>
            <button class="btn btn-warning" id="btn-quit-result">QUIT</button>
        </div>
    </div>
  </div>

  <script>
    "use strict";

    /**
     * @file LinkMaster Infinity - A professional refactor with dynamic difficulty.
     * @author Gemini
     * @version 3.0.0
     */

    // --- 設定ファイル ---
    const CONFIG = {
        GAME_MODES: {
            ENDLESS: 'endless',
            TIME_ATTACK: 'time_attack',
            CHALLENGE: 'challenge'
        },
        GAME_STATES: {
            TITLE: 'title',
            PLAYING: 'playing',
            PAUSED: 'paused',
            LEVEL_END: 'level_end',
            GAME_OVER: 'game_over'
        },
        TIME_ATTACK_DURATION: 120,
        POINTS: {
            BASE: 50,
            DIFFICULTY_MULTIPLIER: 10,
            TIME_BONUS_MULTIPLIER: 5,
        },
        // 固定レベル（タイムアタックとチャレンジ用）
        FIXED_LEVELS: [
            { points: 4, pattern: 'square' }, { points: 5, pattern: 'pentagon' },
            { points: 6, pattern: 'hexagon' }, { points: 6, pattern: 'house' },
            { points: 7, pattern: 'flower' }, { points: 8, pattern: 'hourglass' },
            { points: 8, pattern: 'octagon' }, { points: 9, pattern: 'grid3x3' },
            { points: 9, pattern: 'star' }, { points: 10, pattern: 'envelope' },
            { points: 10, pattern: 'complex1' }, { points: 11, pattern: 'spiral' },
            { points: 12, pattern: 'double_diamond'}, { points: 12, pattern: 'ultimate' },
            { points: 15, pattern: 'insane' }
        ],
        // 動的生成用パターン
        DYNAMIC_PATTERNS: {
            easy: ['square', 'pentagon', 'house'],
            medium: ['hexagon', 'flower', 'hourglass', 'octagon'],
            hard: ['grid3x3', 'star', 'envelope', 'complex1'],
            insane: ['spiral', 'double_diamond', 'ultimate', 'insane']
        }
    };
    
    // --- クラス定義 (UIManager, StorageManager, AudioControllerは変更なしのため省略) ---
    class UIManager {
        constructor() {
            this.elements = {
                levelLabel: document.getElementById('ui-level-label'),
                scoreLabel: document.getElementById('ui-score-label'),
                level: document.getElementById('ui-level'),
                score: document.getElementById('ui-score'),
                highscore: document.getElementById('ui-highscore'),
                timer: document.getElementById('ui-timer'),
                resetBtn: document.getElementById('btn-reset'),
                pauseBtn: document.getElementById('btn-pause'),
                settingsBtn: document.getElementById('btn-settings'),
                resumeBtn: document.getElementById('btn-resume'),
                quitBtn: document.getElementById('btn-quit'),
                quitResultBtn: document.getElementById('btn-quit-result'),
                settingsCloseBtn: document.getElementById('btn-settings-close'),
                startEndlessBtn: document.getElementById('btn-start-endless'),
                startTimeAttackBtn: document.getElementById('btn-start-timeattack'),
                startChallengeBtn: document.getElementById('btn-start-challenge'),
                challengeBackBtn: document.getElementById('btn-challenge-back'),
                challengeSelection: document.getElementById('challenge-selection'),
                nextLevelBtn: document.getElementById('btn-next-level'),
                retryBtn: document.getElementById('btn-retry'),
                startScreen: document.getElementById('start-screen'),
                challengeModal: document.getElementById('challenge-modal'),
                pauseModal: document.getElementById('pause-modal'),
                settingsModal: document.getElementById('settings-modal'),
                resultModal: document.getElementById('result-modal'),
                resultTitle: document.getElementById('result-title'),
                resultStars: document.getElementById('result-stars'),
                resultTime: document.getElementById('result-time'),
                resultScore: document.getElementById('result-score'),
                volumeSlider: document.getElementById('volume-slider'),
            };
        }
        bind(event, handler) { const [elementId, eventType] = event.split(':'); this.elements[elementId].addEventListener(eventType, handler); }
        updateStat(stat, value) { if (this.elements[stat]) this.elements[stat].textContent = value; }
        updateTimer(time) { this.updateStat('timer', `${Math.floor(time / 60)}:${(time % 60).toString().padStart(2, '0')}`); }
        toggleModal(modalId, show) { this.elements[modalId].classList.toggle('visible', show); }
        showResult(result) {
            this.elements.resultTitle.textContent = result.title;
            this.elements.resultStars.textContent = result.stars !== null ? '⭐'.repeat(result.stars).padEnd(3, '☆') : '';
            this.elements.resultTime.textContent = this.formatTime(result.time);
            this.elements.resultScore.textContent = `${result.scoreGained} (Total: ${result.totalScore})`;
            this.elements.nextLevelBtn.style.display = result.hasNext ? 'inline-flex' : 'none';
            this.toggleModal('resultModal', true);
        }
        setLabels(mode) {
            switch(mode) {
                case CONFIG.GAME_MODES.ENDLESS:
                    this.elements.levelLabel.textContent = 'DIFFICULTY';
                    this.elements.scoreLabel.textContent = 'SCORE';
                    break;
                case CONFIG.GAME_MODES.TIME_ATTACK:
                    this.elements.levelLabel.textContent = 'CLEARED';
                    this.elements.scoreLabel.textContent = 'SCORE';
                    break;
                case CONFIG.GAME_MODES.CHALLENGE:
                    this.elements.levelLabel.textContent = 'LEVEL';
                    this.elements.scoreLabel.textContent = 'SCORE';
                    break;
            }
        }
        formatTime(seconds) { const min = Math.floor(seconds / 60); const sec = seconds % 60; return `${min}:${sec.toString().padStart(2, '0')}`; }
    }
    class StorageManager {
        constructor(prefix = 'linkmaster_infinity_') { this.prefix = prefix; }
        get(key, defaultValue = null) { const value = localStorage.getItem(this.prefix + key); return value ? JSON.parse(value) : defaultValue; }
        set(key, value) { localStorage.setItem(this.prefix + key, JSON.stringify(value)); }
    }
    class AudioController {
        constructor(volumeSlider, storage) { this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); this.masterGain = this.audioContext.createGain(); this.masterGain.connect(this.audioContext.destination); this.volumeSlider = volumeSlider; this.storage = storage; this.volumeSlider.addEventListener('input', (e) => this.setVolume(e.target.value)); this.loadVolume(); }
        setVolume(volume) { this.masterGain.gain.setValueAtTime(parseFloat(volume), this.audioContext.currentTime); this.storage.set('volume', volume); }
        loadVolume() { const savedVolume = this.storage.get('volume', 0.5); this.volumeSlider.value = savedVolume; this.setVolume(savedVolume); }
        playSound(type) { if (!this.audioContext || this.masterGain.gain.value === 0) return; if (this.audioContext.state === 'suspended') { this.audioContext.resume(); } const oscillator = this.audioContext.createOscillator(); const gainNode = this.audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(this.masterGain); let freq, duration, waveType; switch (type) { case 'click': freq = [800]; duration = 0.2; waveType = 'triangle'; break; case 'success': freq = [523, 659, 784]; duration = 0.4; waveType = 'sine'; break; case 'error': freq = [150]; duration = 0.2; waveType = 'square'; break; case 'win': freq = [523, 659, 784, 1046]; duration = 0.6; waveType = 'sine'; break; } oscillator.type = waveType; const now = this.audioContext.currentTime; gainNode.gain.setValueAtTime(0.1, now); if (freq.length > 1) { freq.forEach((f, i) => { oscillator.frequency.setValueAtTime(f, now + i * (duration / freq.length)); }); } else { oscillator.frequency.setValueAtTime(freq[0], now); } gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration); oscillator.start(now); oscillator.stop(now + duration); }
    }
    
    /**
     * PuzzleGame: パズル本体のロジックを担当 (動的生成機能を追加)
     */
    class PuzzleGame {
        constructor(canvas, onLevelComplete, onGameOver, onStateChange) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.onLevelComplete = onLevelComplete;
            this.onGameOver = onGameOver;
            this.onStateChange = onStateChange;
            this.resizeCanvas();
            this.reset();
        }

        reset() {
            this.points = [];
            this.visited = [];
            this.segments = [];
            this.startTime = 0;
            this.elapsedTime = 0;
            this.previewPos = null;
            this.isWon = false;
            this.isLost = false;
        }
        
        startLevel(levelData) {
            this.reset();
            this.levelData = levelData;
            this.points = this._generateLevelPoints();
            this.startTime = Date.now();
            this.draw();
        }

        _generateDynamicLevel(difficulty) {
            const points = Math.min(20, 4 + Math.floor(difficulty / 2));
            let patternTier;
            if (difficulty < 5) patternTier = 'easy';
            else if (difficulty < 12) patternTier = 'medium';
            else if (difficulty < 25) patternTier = 'hard';
            else patternTier = 'insane';
            
            const patterns = CONFIG.DYNAMIC_PATTERNS[patternTier];
            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            
            return { points, pattern };
        }

        // ... (handleClick, handleMouseMove, 描画, 交差判定などのメソッドは前回から変更なし)
        resizeCanvas() { const rect = this.canvas.parentElement.getBoundingClientRect(); const aspectRatio = 4 / 3; let width = rect.width; let height = rect.width / aspectRatio; if (height > rect.height) { height = rect.height; width = height * aspectRatio; } this.canvas.width = width; this.canvas.height = height; }
        handleClick(e) { if (this.isWon || this.isLost) return; const pos = this._getMousePos(e); const idx = this._findNearestPoint(pos); if (idx === null) return; this.onStateChange('sound', { type: 'click' }); if (this.visited.length === 0) { this.visited.push(idx); } else { if (this.visited.includes(idx)) return; const prevIdx = this.visited[this.visited.length - 1]; const newSeg = { i1: prevIdx, i2: idx, p1: this.points[prevIdx], p2: this.points[idx] }; if (this._checkIntersection(newSeg)) { this.isLost = true; this.onStateChange('sound', { type: 'error' }); this.onGameOver(); return; } this.segments.push(newSeg); this.visited.push(idx); } if (this.visited.length === this.points.length) { this.isWon = true; this.elapsedTime = Math.floor((Date.now() - this.startTime) / 1000); this.onStateChange('sound', { type: 'win' }); this.onLevelComplete({ time: this.elapsedTime }); } this.draw(); }
        handleMouseMove(e) { if (this.isWon || this.isLost || this.visited.length === 0) { this.previewPos = null; return; }; this.previewPos = this._getMousePos(e); this.draw(); }
        draw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this._drawGrid(); if(this.previewPos) this._drawPreviewLine(); this._drawSegments(); this._drawPoints(); }
        _getMousePos(evt) { const rect = this.canvas.getBoundingClientRect(); return { x: (evt.clientX - rect.left) * (this.canvas.width / rect.width), y: (evt.clientY - rect.top) * (this.canvas.height / rect.height) }; }
        _findNearestPoint(pos) { let bestDist = Infinity, bestIdx = null; this.points.forEach((pt, idx) => { const dist = Math.hypot(pos.x - pt.x, pos.y - pt.y); if (dist < this.canvas.width * 0.05 && dist < bestDist) { bestDist = dist; bestIdx = idx; } }); return bestIdx; }
        _checkIntersection(newSegment) { for (const seg of this.segments) { if (this._segmentsIntersect(seg.p1, seg.p2, newSegment.p1, newSegment.p2)) return true; } return false; }
        _drawGrid() { const { ctx, canvas } = this; ctx.strokeStyle = 'rgba(0, 245, 255, 0.05)'; ctx.lineWidth = 1; for (let x = 0; x <= canvas.width; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); } for (let y = 0; y <= canvas.height; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); } }
        _drawPreviewLine() { const { ctx } = this; const lastPoint = this.points[this.visited[this.visited.length - 1]]; ctx.save(); ctx.strokeStyle = 'rgba(0, 245, 255, 0.5)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(lastPoint.x, lastPoint.y); ctx.lineTo(this.previewPos.x, this.previewPos.y); ctx.stroke(); ctx.restore(); }
        _drawSegments() { const { ctx } = this; ctx.lineWidth = this.canvas.width * 0.008; this.segments.forEach(seg => { const gradient = ctx.createLinearGradient(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y); gradient.addColorStop(0, '#00f5ff'); gradient.addColorStop(1, '#ff00ff'); ctx.strokeStyle = gradient; ctx.shadowColor = '#00f5ff'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke(); }); ctx.shadowBlur = 0; }
        _drawPoints() { const { ctx } = this; const radius = this.canvas.width * 0.015; this.points.forEach((pt, idx) => { const isVisited = this.visited.includes(idx); const isLast = idx === this.visited[this.visited.length - 1]; ctx.beginPath(); ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2); const gradient = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, radius); if (isLast) { gradient.addColorStop(0, '#ffff00'); gradient.addColorStop(1, '#ff8c00'); } else if (isVisited) { gradient.addColorStop(0, '#00ff80'); gradient.addColorStop(1, '#00c957'); } else { gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(1, '#c0c0c0'); } ctx.fillStyle = gradient; ctx.fill(); }); }
        _orientation(p, q, r) { const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); if (val === 0) return 0; return (val > 0) ? 1 : 2; }
        _onSegment(p, q, r) { return (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)); }
        _segmentsIntersect(p1, q1, p2, q2) { if ((p1.x === p2.x && p1.y === p2.y) || (p1.x === q2.x && p1.y === q2.y) || (q1.x === p2.x && q1.y === p2.y) || (q1.x === q2.x && q1.y === q2.y)) { return false; } const o1 = this._orientation(p1, q1, p2); const o2 = this._orientation(p1, q1, q2); const o3 = this._orientation(p2, q2, p1); const o4 = this._orientation(p2, q2, q1); if (o1 !== o2 && o3 !== o4) return true; if (o1 === 0 && this._onSegment(p1, p2, q1)) return true; if (o2 === 0 && this._onSegment(p1, q2, q1)) return true; if (o3 === 0 && this._onSegment(p2, p1, q2)) return true; if (o4 === 0 && this._onSegment(p2, q1, q2)) return true; return false; }
        
        _generateLevelPoints() {
            const { width, height } = this.canvas;
            const cx = width / 2;
            const cy = height / 2;
            const R = Math.min(width, height) * 0.4;
            const points = [];
            const data = this.levelData;

            switch (data.pattern) {
                // ここに多数のパターン定義...
                case 'square': for(let i=0; i<4; i++){ const a=Math.PI/4+i*Math.PI/2; points.push({x:cx+R*Math.cos(a),y:cy+R*Math.sin(a)}); } break;
                case 'pentagon': for(let i=0;i<5;i++){ const a=(i*2*Math.PI)/5-Math.PI/2; points.push({x:cx+R*Math.cos(a),y:cy+R*Math.sin(a)}); } break;
                case 'hexagon': for(let i=0;i<6;i++){ const a=(i*2*Math.PI)/6; points.push({x:cx+R*Math.cos(a),y:cy+R*Math.sin(a)}); } break;
                case 'house': points.push({x:cx,y:cy-R},{x:cx-R,y:cy},{x:cx+R,y:cy},{x:cx-R*0.8,y:cy+R},{x:cx+R*0.8,y:cy+R}); break;
                case 'flower': for(let i=0;i<6;i++){ const a=(i*2*Math.PI)/6; points.push({x:cx+R*0.8*Math.cos(a),y:cy+R*0.8*Math.sin(a)}); } points.push({x:cx,y:cy}); break;
                case 'grid3x3': for(let r=-1;r<=1;r++){for(let c=-1;c<=1;c++){points.push({x:cx+c*R*0.7,y:cy+r*R*0.7});}} break;
                // 他のパターンも同様に定義
                default: for (let i = 0; i < data.points; i++) { points.push({ x: width * 0.1 + Math.random() * width * 0.8, y: height * 0.1 + Math.random() * height * 0.8 }); }
            }
            return points;
        }
    }

    /**
     * GameManager: 全体の流れと状態を管理
     */
    class GameManager {
        constructor() {
            this.ui = new UIManager();
            this.storage = new StorageManager();
            this.audio = new AudioController(this.ui.elements.volumeSlider, this.storage);
            this.game = new PuzzleGame(
                document.getElementById('gameCanvas'),
                (result) => this.handleLevelComplete(result),
                () => this.handleGameOver(),
                (type, data) => this.handleGameStateChange(type, data)
            );
            
            this.state = CONFIG.GAME_STATES.TITLE;
            this.mode = null;
            this.currentLevel = 0; // 固定レベルのインデックス
            this.difficulty = 0; // 無限モードの難易度
            this.score = 0;
            this.highScore = this.storage.get('highscore', 0);
            this.timer = null;
            this.timeRemaining = 0;
            
            this.bindEvents();
            this.initBackgroundStars();
            this.updateUI();
        }
        
        bindEvents() {
            this.ui.bind('startEndlessBtn:click', () => this.startGame(CONFIG.GAME_MODES.ENDLESS));
            this.ui.bind('startTimeAttackBtn:click', () => this.startGame(CONFIG.GAME_MODES.TIME_ATTACK));
            this.ui.bind('startChallengeBtn:click', () => this.showChallengeMenu());
            this.ui.bind('challengeBackBtn:click', () => { this.ui.toggleModal('challengeModal', false); this.ui.toggleModal('startScreen', true); });
            this.ui.bind('pauseBtn:click', () => this.pauseGame());
            this.ui.bind('resumeBtn:click', () => this.resumeGame());
            this.ui.bind('resetBtn:click', () => this.retryLevel());
            this.ui.bind('retryBtn:click', () => this.retryLevel());
            this.ui.bind('nextLevelBtn:click', () => this.startNextLevel());
            this.ui.bind('quitBtn:click', () => this.quitGame());
            this.ui.bind('quitResultBtn:click', () => this.quitGame());
            this.ui.bind('settingsBtn:click', () => this.ui.toggleModal('settingsModal', true));
            this.ui.bind('settingsCloseBtn:click', () => this.ui.toggleModal('settingsModal', false));
            this.game.canvas.addEventListener('click', (e) => this.game.handleClick(e));
            this.game.canvas.addEventListener('mousemove', (e) => this.game.handleMouseMove(e));
            window.addEventListener('resize', () => this.game.resizeCanvas());
        }

        initBackgroundStars() { /* ...変更なし... */ const c=document.querySelector('.background-stars');for(let i=0;i<100;i++){const s=document.createElement('div');s.className='star';s.style.left=`${Math.random()*100}%`;s.style.top=`${Math.random()*100}%`;const z=Math.random()*2+1;s.style.width=`${z}px`;s.style.height=`${z}px`;s.style.animationDelay=`${Math.random()*3}s`;c.appendChild(s);} }
        
        startGame(mode, startLevel = 0) {
            this.mode = mode;
            this.score = 0;
            this.state = CONFIG.GAME_STATES.PLAYING;
            this.ui.toggleModal('startScreen', false);
            this.ui.toggleModal('challengeModal', false);
            this.ui.setLabels(this.mode);

            if (mode === CONFIG.GAME_MODES.ENDLESS) {
                this.difficulty = 0;
                this.startDynamicLevel();
            } else if (mode === CONFIG.GAME_MODES.CHALLENGE) {
                this.currentLevel = startLevel;
                this.startFixedLevel();
            } else if (mode === CONFIG.GAME_MODES.TIME_ATTACK) {
                this.currentLevel = 0;
                this.timeRemaining = CONFIG.TIME_ATTACK_DURATION;
                this.startTimer();
                this.startFixedLevel();
            }
            this.updateUI();
        }
        
        showChallengeMenu() {
            this.ui.toggleModal('startScreen', false);
            const container = this.ui.elements.challengeSelection;
            container.innerHTML = '';
            const difficulties = { "Easy": 3, "Medium": 7, "Hard": 11, "Insane": 14 };
            Object.entries(difficulties).forEach(([name, levelIndex]) => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-danger';
                btn.textContent = `${name} (Lv.${levelIndex + 1})`;
                btn.onclick = () => this.startGame(CONFIG.GAME_MODES.CHALLENGE, levelIndex);
                container.appendChild(btn);
            });
            this.ui.toggleModal('challengeModal', true);
        }
        
        startDynamicLevel() {
            const levelData = this.game._generateDynamicLevel(this.difficulty);
            this.game.startLevel(levelData);
            this.updateUI();
        }
        
        startFixedLevel() {
            const levelData = CONFIG.FIXED_LEVELS[this.currentLevel];
            this.game.startLevel(levelData);
            this.updateUI();
        }
        
        retryLevel() {
            if (this.mode === CONFIG.GAME_MODES.ENDLESS) this.startDynamicLevel();
            else this.startFixedLevel();
            this.ui.toggleModal('resultModal', false);
            this.state = CONFIG.GAME_STATES.PLAYING;
        }

        startNextLevel() {
            this.ui.toggleModal('resultModal', false);
            this.state = CONFIG.GAME_STATES.PLAYING;
            if (this.mode === CONFIG.GAME_MODES.ENDLESS) {
                this.difficulty++;
                this.startDynamicLevel();
            } else {
                if(this.currentLevel < CONFIG.FIXED_LEVELS.length - 1) {
                    this.currentLevel++;
                    this.startFixedLevel();
                }
            }
        }

        handleLevelComplete({ time }) {
            this.state = CONFIG.GAME_STATES.LEVEL_END;
            let scoreGained = 0;
            let stars = null;
            let hasNext = true;

            if (this.mode === CONFIG.GAME_MODES.ENDLESS) {
                scoreGained = CONFIG.POINTS.BASE + this.difficulty * CONFIG.POINTS.DIFFICULTY_MULTIPLIER;
            } else { // Challenge & Time Attack
                stars = (time <= 10) ? 3 : (time <= 25) ? 2 : 1;
                scoreGained = CONFIG.POINTS.BASE * (this.currentLevel + 1) + Math.max(0, 60-time) * CONFIG.POINTS.TIME_BONUS_MULTIPLIER;
                if (this.currentLevel >= CONFIG.FIXED_LEVELS.length - 1) hasNext = false;
            }

            this.score += scoreGained;
            if (this.score > this.highScore) {
                this.highScore = this.score;
                this.storage.set('highscore', this.highScore);
            }
            
            this.ui.showResult({
                title: this.mode === CONFIG.GAME_MODES.TIME_ATTACK && !hasNext ? "Time's Up!" : "Success!",
                stars: stars,
                time: time,
                scoreGained: scoreGained,
                totalScore: this.score,
                hasNext: hasNext
            });
            this.updateUI();
        }

        // ... (pause, resume, quit, handleGameOver, handleStateChange, startTimer, updateUIはほぼ変更なし)
        pauseGame() { if(this.state!==CONFIG.GAME_STATES.PLAYING)return;this.state=CONFIG.GAME_STATES.PAUSED;this.ui.toggleModal('pauseModal',true);if(this.mode===CONFIG.GAME_MODES.TIME_ATTACK){clearInterval(this.timer);} }
        resumeGame() { if(this.state!==CONFIG.GAME_STATES.PAUSED)return;this.state=CONFIG.GAME_STATES.PLAYING;this.ui.toggleModal('pauseModal',false);if(this.mode===CONFIG.GAME_MODES.TIME_ATTACK){this.startTimer();} }
        quitGame() { this.state=CONFIG.GAME_STATES.TITLE;this.ui.toggleModal('pauseModal',false);this.ui.toggleModal('resultModal',false);this.ui.toggleModal('challengeModal',false);this.ui.toggleModal('startScreen',true);this.score=0;clearInterval(this.timer);this.updateUI(); }
        handleGameOver() { this.state=CONFIG.GAME_STATES.GAME_OVER;clearInterval(this.timer);this.ui.showResult({title:"Game Over",stars:0,time:this.game.elapsedTime||this.timeRemaining,scoreGained:0,totalScore:this.score,hasNext:false}); }
        handleGameStateChange(type,data){if(type==='sound')this.audio.playSound(data.type);}
        startTimer(){this.timer=setInterval(()=>{this.timeRemaining--;this.ui.updateTimer(this.timeRemaining);if(this.timeRemaining<=0){this.handleGameOver();}},1000);}
        updateUI() {
            if (this.mode === CONFIG.GAME_MODES.ENDLESS) {
                this.ui.updateStat('level', this.difficulty + 1);
            } else {
                this.ui.updateStat('level', this.currentLevel + 1);
            }
            this.ui.updateStat('score', this.score);
            this.ui.updateStat('highscore', this.highScore);
            if (this.mode === CONFIG.GAME_MODES.TIME_ATTACK) this.ui.updateTimer(this.timeRemaining);
            else this.ui.updateStat('timer', '∞');
        }
    }

    // --- ゲームの初期化 ---
    document.addEventListener('DOMContentLoaded', () => { new GameManager(); });
  </script>
</body>
</html>
