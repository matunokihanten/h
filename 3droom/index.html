<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern 3D Room Editor - Photo Wall</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #canvas-container { width: 100%; height: 100%; cursor: pointer; }
        .main-panel { position: absolute; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.85); border-radius: 12px; padding: 10px; width: 220px; max-height: calc(100vh - 40px); overflow-y: auto; z-index: 10; }
        .main-panel.hidden { display: none; }
        .tab-nav { display: flex; margin-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .tab-button { flex-grow: 1; background: rgba(255, 255, 255, 0.1); border: none; color: white; cursor: pointer; padding: 8px; }
        .tab-button.active { background: #42a5f5; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .btn { background: linear-gradient(45deg, #42a5f5, #1e88e5); border: none; color: white; padding: 6px 10px; cursor: pointer; width: 100%; margin-bottom: 5px; border-radius: 4px; }
        .btn.danger { background: linear-gradient(45deg, #f44336, #d32f2f); }
        .btn.success { background: linear-gradient(45deg, #4caf50, #388e3c); }
        .object-list { max-height: 120px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); padding: 5px; border-radius: 4px; }
        .object-item { background: rgba(255, 255, 255, 0.1); padding: 4px; cursor: pointer; margin-bottom: 2px; border-radius: 2px; }
        .object-item.selected { background: rgba(66, 165, 245, 0.3); }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; }
        .spinner { border: 3px solid rgba(255, 255, 255, 0.3); border-top: 3px solid #42a5f5; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .slider-container { margin-bottom: 10px; }
        .slider-label { font-size: 0.9em; color: #eee; margin-bottom: 3px; display: block; }
        .slider { width: 100%; }
        .panel-title { font-size: 1.1em; margin-bottom: 10px; color: #eee; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 5px; }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        <div class="loading" id="loading"><div class="spinner"></div><div>読み込み中...</div></div>
        <div class="main-panel" id="mainPanel">
            <button class="btn" id="toggleUIVisibility">UIを隠す</button>
            <div class="tab-nav">
                <button class="tab-button active" data-tab="control">操作</button>
                <button class="tab-button" data-tab="object">追加</button>
                <button class="tab-button" data-tab="transform">調整</button>
                <button class="tab-button" data-tab="data">データ</button>
            </div>
            <div id="control-tab" class="tab-content active">
                <div class="panel-title">🎛️ コントロール</div>
                <button class="btn" id="toggleAutoRotate">自動回転 OFF</button>
                <button class="btn" id="toggleLighting">照明 ON</button>
                <button class="btn" id="resetCamera">カメラリセット</button>
                <div class="slider-container">
                    <div class="slider-label">回転速度</div>
                    <input type="range" class="slider" id="rotationSpeed" min="0.001" max="0.02" step="0.001" value="0.005">
                </div>
            </div>
            <div id="object-tab" class="tab-content">
                <div class="panel-title">🪑 オブジェクト追加</div>
                <button class="btn success" id="addPhotoBtn">写真を壁に追加</button>
                <input type="file" id="photoInput" accept="image/*" style="display: none;">
                <button class="btn" id="addChair">椅子を追加</button>
                <button class="btn" id="addTable">テーブルを追加</button>
                <button class="btn" id="addLamp">ランプを追加</button>
                <button class="btn" id="addSofa">ソファを追加</button>
                <button class="btn" id="addBookshelf">本棚を追加</button>
                <button class="btn" id="addPlant">観葉植物を追加</button>
                <button class="btn danger" id="deleteSelected">選択を削除</button>
                <div class="object-list" id="objectList"></div>
            </div>
            <div id="transform-tab" class="tab-content">
                <div class="panel-title">📍 選択オブジェクト</div>
                <div id="selectedInfo">オブジェクトを選択してください</div>
                <div id="transformControls" style="display: none;">
                    <div class="slider-container"><div class="slider-label">X位置</div><input type="range" class="slider" id="posX" min="-5" max="5" step="0.1" value="0"></div>
                    <div class="slider-container"><div class="slider-label">Y位置</div><input type="range" class="slider" id="posY" min="0" max="3" step="0.1" value="0"></div>
                    <div class="slider-container"><div class="slider-label">Z位置</div><input type="range" class="slider" id="posZ" min="-5" max="5" step="0.1" value="0"></div>
                    <div class="slider-container"><div class="slider-label">回転</div><input type="range" class="slider" id="rotY" min="0" max="6.28" step="0.1" value="0"></div>
                </div>
            </div>
            <div id="data-tab" class="tab-content">
                <div class="panel-title">💾 データ</div>
                <button class="btn success" id="saveRoom">部屋を保存</button>
                <button class="btn" id="loadRoom">部屋を読み込み</button>
                <button class="btn danger" id="clearRoom">全てクリア</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, room;
        let autoRotate = false, rotationSpeed = 0.005, selectedObject = null, objectCount = 0, roomObjects = [];
        let ambientLight, directionalLight, isManualControl = false, mouse = new THREE.Vector2(), raycaster = new THREE.Raycaster();
        let lightingEnabled = true;

        let lastIntersectPoint = null;
        let clickedWall = null;
        let wallMaterial; // 壁マテリアルをグローバルで参照可能に

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 6); // 少し引いて見やすく
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            createRoom();
            setupLighting();
            setupControls();
            setupEventListeners();
            
            setTimeout(() => { 
                if (!isManualControl) { 
                    autoRotate = true; 
                    document.getElementById('toggleAutoRotate').textContent = '自動回転 ON'; 
                }
            }, 5000);
            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function createRoom() {
            room = new THREE.Group();
            const roomSize = 10, roomHeight = 4;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), new THREE.MeshLambertMaterial({ color: 0x2c3e50 }));
            floor.rotation.x = -Math.PI / 2; 
            floor.receiveShadow = true; 
            floor.name = 'floor';
            room.add(floor);
            
            wallMaterial = new THREE.MeshLambertMaterial({ color: 0x34495e, side: THREE.DoubleSide });
            
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomHeight), wallMaterial);
            backWall.position.set(0, roomHeight / 2, -roomSize / 2);
            backWall.name = 'backWall';
            room.add(backWall);

            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomHeight), wallMaterial);
            leftWall.position.set(-roomSize / 2, roomHeight / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.name = 'leftWall';
            room.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomHeight), wallMaterial);
            rightWall.position.set(roomSize / 2, roomHeight / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.name = 'rightWall';
            room.add(rightWall);
            
            scene.add(room);
        }
        
        function addPhotoToWall(dataUrl) {
            if (!clickedWall) {
                alert("先に写真を貼りたい壁をクリックしてください。");
                return;
            }

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(dataUrl, (texture) => {
                const aspectRatio = texture.image.width / texture.image.height;
                const photoWidth = 1.5; // 写真の基本幅
                const photoHeight = photoWidth / aspectRatio;

                const photoGeometry = new THREE.PlaneGeometry(photoWidth, photoHeight);
                const photoMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const photoMesh = new THREE.Mesh(photoGeometry, photoMaterial);

                // ワールド座標から壁のローカル座標に変換
                const localPoint = clickedWall.worldToLocal(lastIntersectPoint.clone());
                photoMesh.position.copy(localPoint);

                // Z-fighting（面のちらつき）を防ぐために少し手前に出す
                photoMesh.position.z += 0.01;

                clickedWall.add(photoMesh);
                
                // リセット
                clickedWall = null;
                lastIntersectPoint = null;
            });
        }

        function onCanvasClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // 壁と家具の両方と交差判定
            const intersects = raycaster.intersectObjects(room.children, true);

            if (intersects.length > 0) {
                const firstHit = intersects[0];
                
                // 壁がクリックされたか判定
                if (firstHit.object.material === wallMaterial) {
                    clickedWall = firstHit.object;
                    lastIntersectPoint = firstHit.point;
                    alert(`壁 (${clickedWall.name}) が選択されました。「写真を壁に追加」ボタンから画像を選んでください。`);
                    deselectObject(); // 家具の選択は解除
                } else {
                    // 家具がクリックされた場合の処理
                    let clickedObject = firstHit.object;
                    while (clickedObject.parent && !roomObjects.includes(clickedObject)) {
                        clickedObject = clickedObject.parent;
                    }
                    if (roomObjects.includes(clickedObject)) {
                        selectObject(clickedObject);
                    }
                    clickedWall = null; // 壁以外の選択をリセット
                }
            } else {
                deselectObject();
                clickedWall = null;
            }
        }
        
        function setupEventListeners() {
            renderer.domElement.addEventListener('click', onCanvasClick);
            
            // Photo Upload Logic
            document.getElementById('addPhotoBtn').addEventListener('click', () => {
                if (!clickedWall) {
                    alert("写真を貼り付けたい壁面を先にクリックしてください。");
                    return;
                }
                document.getElementById('photoInput').click();
            });

            document.getElementById('photoInput').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        addPhotoToWall(e.target.result);
                    };
                    reader.readAsDataURL(file);
                }
                // 同じファイルを連続でアップロードできるように値をリセット
                event.target.value = null; 
            });

            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    event.target.classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById(event.target.dataset.tab + '-tab').classList.add('active');
                });
            });
            document.getElementById('toggleAutoRotate').addEventListener('click', toggleAutoRotate);
            document.getElementById('toggleLighting').addEventListener('click', toggleLighting);
            document.getElementById('resetCamera').addEventListener('click', resetCamera);
            document.getElementById('rotationSpeed').addEventListener('input', event => rotationSpeed = parseFloat(event.target.value));
            document.getElementById('addChair').addEventListener('click', () => addObject('chair'));
            document.getElementById('addTable').addEventListener('click', () => addObject('table'));
            document.getElementById('addLamp').addEventListener('click', () => addObject('lamp'));
            document.getElementById('addSofa').addEventListener('click', () => addObject('sofa'));
            document.getElementById('addBookshelf').addEventListener('click', () => addObject('bookshelf'));
            document.getElementById('addPlant').addEventListener('click', () => addObject('plant'));
            document.getElementById('deleteSelected').addEventListener('click', deleteSelected);
            document.getElementById('posX').addEventListener('input', updateSelectedPosition);
            document.getElementById('posY').addEventListener('input', updateSelectedPosition);
            document.getElementById('posZ').addEventListener('input', updateSelectedPosition);
            document.getElementById('rotY').addEventListener('input', updateSelectedRotation);
            document.getElementById('saveRoom').addEventListener('click', saveRoom);
            document.getElementById('loadRoom').addEventListener('click', loadRoom);
            document.getElementById('clearRoom').addEventListener('click', clearRoom);
            document.getElementById('toggleUIVisibility').addEventListener('click', toggleUIVisibility);
            window.addEventListener('resize', onWindowResize);
        }

        // --- 以下、既存の関数群（一部修正なし） ---
        
        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x404040, lightingEnabled ? 0.8 : 0.2); scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, lightingEnabled ? 0.9 : 0.2); directionalLight.position.set(5, 10, 7.5); directionalLight.castShadow = true;
            scene.add(directionalLight);
        }

        function setupControls() {
            let isMouseDown = false, mouseX = 0, mouseY = 0;
            const domElement = renderer.domElement;
            domElement.addEventListener('mousedown', (event) => { if (event.button === 0) { isMouseDown = true; isManualControl = true; mouseX = event.clientX; mouseY = event.clientY; } });
            domElement.addEventListener('mousemove', (event) => { if (isMouseDown) { const deltaX = event.clientX - mouseX, deltaY = event.clientY - mouseY; room.rotation.y += deltaX * 0.01; room.rotation.x += deltaY * 0.01; room.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, room.rotation.x)); mouseX = event.clientX; mouseY = event.clientY; } });
            domElement.addEventListener('mouseup', () => { isMouseDown = false; setTimeout(() => { isManualControl = false; }, 1000); });
            domElement.addEventListener('touchstart', (event) => { if (event.touches.length === 1) { isMouseDown = true; isManualControl = true; mouseX = event.touches[0].clientX; mouseY = event.touches[0].clientY; } });
            domElement.addEventListener('touchmove', (event) => { if (isMouseDown && event.touches.length === 1) { const deltaX = event.touches[0].clientX - mouseX, deltaY = event.touches[0].clientY - mouseY; room.rotation.y += deltaX * 0.01; room.rotation.x += deltaY * 0.01; room.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, room.rotation.x)); mouseX = event.touches[0].clientX; mouseY = event.touches[0].clientY; } event.preventDefault(); });
            domElement.addEventListener('touchend', () => { isMouseDown = false; setTimeout(() => { isManualControl = false; }, 1000); });
        }
        
        function selectObject(object) {
            if (selectedObject) selectedObject.traverse(child => { if (child.isMesh) child.material.emissive.setHex(0x000000); });
            selectedObject = object;
            object.traverse(child => { if (child.isMesh) child.material.emissive.setHex(0x444444); });
            updateSelectedInfo(); updateObjectList();
        }

        function deselectObject() {
            if (selectedObject) selectedObject.traverse(child => { if (child.isMesh) child.material.emissive.setHex(0x000000); });
            selectedObject = null;
            updateSelectedInfo(); updateObjectList();
        }

        function updateSelectedInfo() {
            const infoDiv = document.getElementById('selectedInfo');
            const transformDiv = document.getElementById('transformControls');
            if (selectedObject) {
                infoDiv.textContent = `選択中: ${selectedObject.name}`;
                transformDiv.style.display = 'block';
                document.getElementById('posX').value = selectedObject.position.x;
                document.getElementById('posY').value = selectedObject.position.y;
                document.getElementById('posZ').value = selectedObject.position.z;
                document.getElementById('rotY').value = selectedObject.rotation.y;
            } else {
                infoDiv.textContent = 'オブジェクトか壁を選択してください。';
                transformDiv.style.display = 'none';
            }
        }

        function updateObjectList() {
            const listDiv = document.getElementById('objectList');
            listDiv.innerHTML = '';
            roomObjects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'object-item';
                if (obj === selectedObject) item.classList.add('selected');
                item.textContent = obj.name;
                item.addEventListener('click', e => { e.stopPropagation(); selectObject(obj); });
                listDiv.appendChild(item);
            });
        }
        
        function addObject(type) {
             let object;
             objectCount++;
             const objectName = `${type}_${objectCount}`;
             // ... (元のaddObjectのswitch文はここにそのままコピー)
             switch(type) {
                case 'chair':
                    object = new THREE.Group();
                    const seat = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.8), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                    seat.position.y = 0.5; seat.castShadow = true; object.add(seat);
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), new THREE.MeshLambertMaterial({ color: 0x654321 }));
                        leg.position.set((i % 2) * 0.7 - 0.35, 0.25, Math.floor(i / 2) * 0.7 - 0.35); leg.castShadow = true; object.add(leg);
                    }
                    const back = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.1), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                    back.position.set(0, 0.9, -0.35); back.castShadow = true; object.add(back);
                    break;
                case 'table':
                    object = new THREE.Group();
                    const top = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 1.0), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                    top.position.y = 0.75; top.castShadow = true; object.add(top);
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.75, 0.1), new THREE.MeshLambertMaterial({ color: 0x654321 }));
                        leg.position.set((i % 2) * 1.4 - 0.7, 0.375, Math.floor(i / 2) * 0.9 - 0.45); leg.castShadow = true; object.add(leg);
                    }
                    break;
                case 'lamp':
                    object = new THREE.Group();
                    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8), new THREE.MeshLambertMaterial({ color: 0x333333 }));
                    base.position.y = 0.05; base.castShadow = true; object.add(base);
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8), new THREE.MeshLambertMaterial({ color: 0x666666 }));
                    pole.position.y = 0.75; pole.castShadow = true; object.add(pole);
                    const shade = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.4, 8), new THREE.MeshLambertMaterial({ color: 0xffffff }));
                    shade.position.y = 1.7; shade.castShadow = true; object.add(shade);
                    break;
                case 'sofa':
                    object = new THREE.Group();
                    const sofaColor = 0x5a2d1f;
                    const mainSeat = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.2, 0.9), new THREE.MeshLambertMaterial({ color: sofaColor }));
                    mainSeat.position.y = 0.4; mainSeat.castShadow = true; object.add(mainSeat);
                    const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.8, 0.2), new THREE.MeshLambertMaterial({ color: sofaColor }));
                    sofaBack.position.set(0, 0.9, -0.45); sofaBack.castShadow = true; object.add(sofaBack);
                    const armrestGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.9);
                    const armrestMaterial = new THREE.MeshLambertMaterial({ color: sofaColor });
                    const armrestLeft = new THREE.Mesh(armrestGeometry, armrestMaterial); armrestLeft.position.set(-0.9, 0.6, 0); armrestLeft.castShadow = true; object.add(armrestLeft);
                    const armrestRight = new THREE.Mesh(armrestGeometry, armrestMaterial); armrestRight.position.set(0.9, 0.6, 0); armrestRight.castShadow = true; object.add(armrestRight);
                    break;
                case 'bookshelf':
                    object = new THREE.Group();
                    const woodColor = 0x5a432b;
                    const sidePanelGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.8);
                    const sidePanelMaterial = new THREE.MeshLambertMaterial({ color: woodColor });
                    const leftPanel = new THREE.Mesh(sidePanelGeometry, sidePanelMaterial); leftPanel.position.set(-0.6, 0.75, 0); leftPanel.castShadow = true; object.add(leftPanel);
                    const rightPanel = new THREE.Mesh(sidePanelGeometry, sidePanelMaterial); rightPanel.position.set(0.6, 0.75, 0); rightPanel.castShadow = true; object.add(rightPanel);
                    const shelfGeometry = new THREE.BoxGeometry(1.3, 0.1, 0.7);
                    const shelfMaterial = new THREE.MeshLambertMaterial({ color: woodColor });
                    for (let i = 0; i < 4; i++) {
                        const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
                        shelf.position.y = 0.1 + (i * 0.45); shelf.castShadow = true; object.add(shelf);
                    }
                    break;
                case 'plant':
                    object = new THREE.Group();
                    const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.2, 0.4, 8), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                    pot.position.y = 0.2; pot.castShadow = true; object.add(pot);
                    const soil = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 0.05, 8), new THREE.MeshLambertMaterial({ color: 0x4a2c0f }));
                    soil.position.y = 0.425; soil.castShadow = true; object.add(soil);
                    const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
                    const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8), new THREE.MeshLambertMaterial({ color: 0x556b2f }));
                    stem.position.y = 0.7; stem.castShadow = true; object.add(stem);
                    const leaves1 = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), leafMaterial); leaves1.position.y = 1.0; leaves1.castShadow = true; object.add(leaves1);
                    break;
            }
             object.name = objectName; 
             object.position.set((Math.random() - 0.5) * 4, 0, (Math.random() - 0.5) * 4);
             // 床の高さに合わせる
             const box = new THREE.Box3().setFromObject(object);
             object.position.y = -box.min.y;

             room.add(object); roomObjects.push(object); updateObjectList();
         }

        function deleteSelected() {
            if (selectedObject) {
                room.remove(selectedObject);
                selectedObject.traverse(o => {
                    if (o.geometry) o.geometry.dispose();
                    if (o.material) o.material.dispose();
                });
                roomObjects = roomObjects.filter(obj => obj !== selectedObject);
                selectedObject = null;
                updateSelectedInfo(); updateObjectList();
            }
        }
        function updateSelectedPosition() { if (selectedObject) { selectedObject.position.set(parseFloat(document.getElementById('posX').value), parseFloat(document.getElementById('posY').value), parseFloat(document.getElementById('posZ').value)); } }
        function updateSelectedRotation() { if (selectedObject) { selectedObject.rotation.y = parseFloat(document.getElementById('rotY').value); } }
        function toggleAutoRotate() { autoRotate = !autoRotate; document.getElementById('toggleAutoRotate').textContent = autoRotate ? '自動回転 ON' : '自動回転 OFF'; }
        function toggleLighting() { lightingEnabled = !lightingEnabled; ambientLight.intensity = lightingEnabled ? 0.8 : 0.2; directionalLight.intensity = lightingEnabled ? 0.9 : 0.2; document.getElementById('toggleLighting').textContent = lightingEnabled ? '照明 ON' : '照明 OFF'; }
        function resetCamera() { room.rotation.set(0, 0, 0); camera.position.set(0, 2, 6); camera.lookAt(0, 0, 0); }
        function toggleUIVisibility() { const mainPanel = document.getElementById('mainPanel'); mainPanel.classList.toggle('hidden'); document.getElementById('toggleUIVisibility').textContent = mainPanel.classList.contains('hidden') ? 'UIを表示' : 'UIを隠す'; }
        function saveRoom() { alert('このバージョンでは、壁に貼り付けた写真は保存されません。家具のみ保存されます。'); const saveData = { objects: roomObjects.map(obj => ({ name: obj.name, position: obj.position.toArray(), rotation: obj.rotation.toArray() })), roomRotation: room.rotation.toArray(), timestamp: new Date().toISOString() }; localStorage.setItem("myRoomData", JSON.stringify(saveData)); alert('家具のデータが保存されました！'); }
        function loadRoom() { const savedDataString = localStorage.getItem("myRoomData"); if (savedDataString) { clearRoom(); const data = JSON.parse(savedDataString); room.rotation.set(...data.roomRotation); data.objects.forEach(objData => { addObject(objData.name.split('_')[0]); const lastObject = roomObjects[roomObjects.length - 1]; lastObject.position.set(...objData.position); lastObject.rotation.set(...objData.rotation); }); alert('部屋のデータが読み込まれました！'); } else { alert('保存されたデータがありません。'); } }
        function clearRoom() { roomObjects.forEach(obj => room.remove(obj)); roomObjects = []; selectedObject = null; objectCount = 0; room.children.filter(c => c.name.includes('Wall')).forEach(wall => { wall.children.slice().forEach(child => wall.remove(child)); }); updateSelectedInfo(); updateObjectList(); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate() { requestAnimationFrame(animate); if (autoRotate && !isManualControl) room.rotation.y += rotationSpeed; renderer.render(scene, camera); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
