<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>積み木マスター - Ultimate Remastered (v2.1)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    :root {
      --glow-color: #<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>積み木マスター - Ultimate Remastered (v2.1)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    :root {
      --glow-color: #FFD700;
      --easy-color: #4CAF50;
      --medium-color: #FF9800;
      --hard-color: #F44336;
      --extreme-color: #9C27B0;
    }
    
    html, body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #1d2b64 0%, #0d0d20 100%);
      font-family: 'Arial', sans-serif;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    #particles-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }
    
    #gameContainer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
    }

    #ui-top, #ui-bottom {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      pointer-events: none;
      max-width: 350px;
      width: 95%;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #ui-top {
        top: 10px;
        opacity: 0;
        transform: translate(-50%, -50px);
        transition: opacity 0.5s ease, transform 0.5s ease;
    }
    #ui-bottom {
        bottom: 10px;
        opacity: 0;
        transform: translate(-50%, 50px);
        transition: opacity 0.5s ease, transform 0.5s ease;
    }
    #ui-top.visible, #ui-bottom.visible {
        opacity: 1;
        transform: translate(-50%, 0);
    }
    #ui-top > *, #ui-bottom > * {
        pointer-events: auto;
    }

    #ui-top h1 {
      margin: 0;
      font-size: 2.5em;
      background: linear-gradient(45deg, var(--glow-color), #FFA500);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      animation: glow 2s ease-in-out infinite alternate;
      text-align: center;
    }
    
    @keyframes glow {
      from { filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5)); }
      to { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
    }

    .game-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .btn {
      padding: 8px 16px;
      border: 2px solid transparent;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
      font-size: 0.9em;
      color: white;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }

    .difficulty-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .difficulty-btn.easy { background: var(--easy-color); }
    .difficulty-btn.medium { background: var(--medium-color); }
    .difficulty-btn.hard { background: var(--hard-color); }
    .difficulty-btn.extreme { background: var(--extreme-color); }
    
    .btn.active {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.2);
    }
    .difficulty-btn.active {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
      border-color: var(--glow-color);
    }
    .difficulty-btn.easy.active { background: var(--easy-color); }
    .difficulty-btn.medium.active { background: var(--medium-color); }
    .difficulty-btn.hard.active { background: var(--hard-color); }
    .difficulty-btn.extreme.active { background: var(--extreme-color); }

    #game-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1.1em;
      font-weight: bold;
    }
    
    #score, #timer {
      color: var(--glow-color);
      font-size: 1.3em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    #streak {
      color: var(--easy-color);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    #answerDisplayContainer {
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        padding: 10px 20px;
        text-align: center;
        backdrop-filter: blur(5px);
    }
    #currentAnswerDisplay {
        font-size: 3em;
        font-weight: bold;
        color: var(--glow-color);
        text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
        min-height: 1.2em;
    }

    /* 変更箇所: 回転ボタンのUIを削除したため、レイアウトを調整 */
    #numpad {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        justify-content: center;
        max-width: 250px; 
        margin: 0 auto;
    }
    #numpad button {
        height: 50px;
        font-size: 1.8em;
        border: none;
        background: rgba(255, 255, 255, 0.4);
        color: white;
        cursor: pointer;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.2s ease;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        height: 40px;
        font-size: 1.5em;
    }
    #numpad button:hover {
        background: rgba(255, 255, 255, 0.6);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #numpad button:active {
        transform: translateY(0);
    }
    #numpad button.action-btn {
        background: rgba(255, 193, 7, 0.3);
        border-color: rgba(255, 193, 7, 0.5);
    }
    
    #submitBtn {
      font-size: 1.8em;
      padding: 12px 30px;
      background: linear-gradient(45deg, var(--easy-color), #45a049);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      opacity: 0.6;
      pointer-events: none;
      width: 100%;
    }
    #submitBtn.active {
        opacity: 1;
        pointer-events: auto;
    }
    #submitBtn:hover.active {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }

    #result {
      font-size: 1.4em;
      font-weight: bold;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      min-height: 1.6em;
      animation: pulse 0.5s ease-in-out;
    }
    
    @keyframes pulse {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-content {
        background: rgba(255, 255, 255, 0.1);
        padding: 40px;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        transform: scale(0.8);
        transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .overlay.visible .overlay-content {
        transform: scale(1);
    }

    .overlay h2 {
      font-size: 4em;
      color: var(--glow-color);
      text-shadow: 4px 4px 8px rgba(0,0,0,0.7);
      margin: 0 0 20px 0;
    }
    
    .overlay p {
      font-size: 1.5em;
      margin: 10px 0;
    }
    
    .overlay-buttons {
      display: flex;
      gap: 20px;
      margin-top: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .overlay-buttons .btn {
      padding: 15px 30px;
      font-size: 1.2em;
      border-radius: 30px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .overlay-buttons .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }
    
    .overlay-buttons .restart { background: var(--easy-color); }
    .overlay-buttons .menu { background: var(--hard-color); }
    .overlay-buttons .start-game { background: var(--easy-color); }
    
    #start-overlay .mode-select {
        margin-bottom: 20px;
    }
    #start-overlay .difficulty-select {
        margin-bottom: 20px;
    }
    #start-overlay .mode-select .btn.active {
        background: var(--easy-color);
        box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        border-color: var(--glow-color);
    }

    @media (max-width: 768px) {
        #ui-top, #ui-bottom {
            max-width: 95%; 
        }
        #ui-top h1 {
            font-size: 1.8em;
        }
        .overlay h2 {
            font-size: 3em;
        }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
</head>
<body>
  <canvas id="particles-bg"></canvas>
  <div id="gameContainer"></div>

  <div id="ui-top">
    <h1>✨ 積み木マスター ✨</h1>
    <div class="game-panel">
      <div id="game-info">
        <div id="timer">⏰ --</div>
        <div id="score">💯 0</div>
        <div id="streak">🔥 0</div>
      </div>
    </div>
  </div>

  <div id="ui-bottom">
    <div class="game-panel">
      <div id="answerDisplayContainer">
        <div id="currentAnswerDisplay">0</div>
      </div>
      <div id="numpad">
        <button data-value="7">7</button><button data-value="8">8</button><button data-value="9">9</button>
        <button data-value="4">4</button><button data-value="5">5</button><button data-value="6">6</button>
        <button data-value="1">1</button><button data-value="2">2</button><button data-value="3">3</button>
        <button data-value="C" class="action-btn">C</button><button data-value="0">0</button><button data-value="del" class="action-btn">←</button>
      </div>
      <button id="submitBtn">🎯 答える</button>
    </div>
    <div id="result"></div>
  </div>

  <div id="start-overlay" class="overlay">
    <div class="overlay-content">
        <h2>積み木マスター</h2>
        <p>ゲームモードを選んでください</p>
        <div class="mode-select overlay-buttons">
            <button class="btn active" data-mode="time-attack">タイムアタック</button>
            <button class="btn" data-mode="zen">禅モード</button>
        </div>
        <p>難易度を選んでください</p>
        <div class="difficulty-select difficulty-controls overlay-buttons">
            <button class="btn difficulty-btn easy active" data-level="easy">初級</button>
            <button class="btn difficulty-btn medium" data-level="medium">中級</button>
            <button class="btn difficulty-btn hard" data-level="hard">上級</button>
            <button class="btn difficulty-btn extreme" data-level="extreme">極限</button>
        </div>
        <div class="overlay-buttons">
            <button class="btn start-game">🚀 ゲーム開始</button>
        </div>
    </div>
  </div>

  <div id="game-overlay" class="overlay">
    <div class="overlay-content">
      <h2 id="overlay-title">ゲームオーバー</h2>
      <p id="overlay-score">スコア: 0</p>
      <p id="overlay-streak">最高連続正解: 0</p>
      <div class="overlay-buttons">
        <button class="btn restart">再挑戦</button>
        <button class="btn menu">メニューに戻る</button>
      </div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, controls;
    let blocks = [];
    let correctBlockCount;
    let gameState = 'start';
    let gameMode = 'time-attack';
    let currentDifficulty = 'easy';

    let score = 0;
    let currentAnswerString = "";
    let currentStreak = 0;
    let bestStreak = 0;
    let timeRemaining = 30;
    let gameTimer;
    // 変更箇所: 自動回転用のタイマー
    let rotationTimer;
    let lastUserInteractionTime = Date.now();
    
    let audioCtx;

    const difficultySettings = {
      easy:   { min: 5,  max: 15,  time: 60, colors: ['#4CAF50', '#8BC34A'], specialBlockChance: 0.1 },
      medium: { min: 10, max: 50,  time: 45, colors: ['#FF9800', '#FFC107'], specialBlockChance: 0.2 },
      hard:   { min: 30, max: 100, time: 30, colors: ['#F44336', '#E91E63'], specialBlockChance: 0.3 },
      extreme:{ min: 50, max: 200, time: 20, colors: ['#9C27B0', '#673AB7'], specialBlockChance: 0.4 }
    };

    const elements = {
      uiTop: document.getElementById('ui-top'),
      uiBottom: document.getElementById('ui-bottom'),
      result: document.getElementById("result"),
      score: document.getElementById("score"),
      currentAnswerDisplay: document.getElementById("currentAnswerDisplay"),
      numpad: document.getElementById("numpad"),
      submitBtn: document.getElementById("submitBtn"),
      timer: document.getElementById("timer"),
      streak: document.getElementById("streak"),
      startOverlay: document.getElementById('start-overlay'),
      gameOverlay: document.getElementById('game-overlay'),
      overlayTitle: document.getElementById('overlay-title'),
      overlayScore: document.getElementById('overlay-score'),
      overlayStreak: document.getElementById('overlay-streak'),
    };
    
    function initApp() {
        initParticles();
        setupEventListeners();
        showStartScreen();
    }

    function startGame() {
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) { console.error("Web Audio API is not supported in this browser."); }
        }
        elements.startOverlay.classList.remove('visible');
        elements.uiTop.classList.add('visible');
        elements.uiBottom.classList.add('visible');
        gameState = 'playing';
        resetStats();
        initThreeJS();
        nextProblem();
    }
    
    function gameOver() {
        gameState = 'gameover';
        clearInterval(gameTimer);
        // 変更箇所: ゲームオーバー時に自動回転タイマーもクリア
        clearInterval(rotationTimer);
        playSound('gameover');
        
        if (gameMode === 'zen') {
            elements.overlayTitle.textContent = "ゲーム終了";
            elements.overlayScore.style.display = 'none';
            elements.overlayStreak.style.display = 'none';
            document.querySelector('#game-overlay .restart').style.display = 'none';
        } else {
            elements.overlayTitle.textContent = "ゲームオーバー";
            elements.overlayScore.style.display = 'block';
            elements.overlayStreak.style.display = 'block';
            document.querySelector('#game-overlay .restart').style.display = 'inline-block';
            elements.overlayScore.textContent = `スコア: ${score}`;
            elements.overlayStreak.textContent = `最高連続正解: ${bestStreak}`;
        }
        elements.gameOverlay.classList.add('visible');
        elements.uiTop.classList.remove('visible');
        elements.uiBottom.classList.remove('visible');
    }
    
    function showStartScreen() {
        gameState = 'start';
        cleanUpThreeJS();
        elements.gameOverlay.classList.remove('visible');
        elements.startOverlay.classList.add('visible');
        elements.uiTop.classList.remove('visible');
        elements.uiBottom.classList.remove('visible');
    }

    function resetStats() {
        score = 0;
        currentStreak = 0;
        bestStreak = 0;
        currentAnswerString = "";
        updateUI();
    }

    function initThreeJS() {
        cleanUpThreeJS();
        const container = document.getElementById("gameContainer");
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 8, 12);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        scene.add(dirLight);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        
        // 変更箇所: controlsにイベントリスナーを追加してユーザー操作を監視
        controls.addEventListener('start', () => {
          lastUserInteractionTime = Date.now();
        });
        
        animate();
    }

    function cleanUpThreeJS() {
        if (!scene) return;
        scene.traverse(object => {
            if (object.isMesh || object.isLineSegments) {
                if(object.geometry) object.geometry.dispose();
                if(object.material) {
                  if (Array.isArray(object.material)) {
                      object.material.forEach(material => material.dispose());
                  } else {
                      object.material.dispose();
                  }
                }
            }
        });
        if (renderer) {
            renderer.dispose();
            const container = document.getElementById("gameContainer");
            if (renderer.domElement && container.contains(renderer.domElement)) {
                container.removeChild(renderer.domElement);
            }
        }
        scene = null; renderer = null; camera = null; controls = null;
    }

    function generateBlocks() {
        blocks.forEach(block => scene.remove(block));
        blocks = [];
        correctBlockCount = 0;
        
        const settings = difficultySettings[currentDifficulty];
        const totalBlockCount = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min;
        const occupied = new Set();
        const queue = ['0,0,0']; 
        occupied.add('0,0,0');
        
        let created = 0;
        while(queue.length > 0 && created < totalBlockCount) {
            const current = queue.shift();
            if (!current) continue;
            const [x, y, z] = current.split(',').map(Number);
            
            let type = 'normal';
            if (Math.random() < settings.specialBlockChance) {
                type = 'bonus';
            }
            
            const blockGroup = createBlock(x, y, z, created, type);
            blocks.push(blockGroup);
            scene.add(blockGroup);
            correctBlockCount++;
            created++;
            
            const directions = [[1,0,0], [-1,0,0], [0,1,0], [0,0,1], [0,0,-1]].sort(() => Math.random() - 0.5);
            for(const [dx, dy, dz] of directions) {
                const nx = x + dx, ny = y + dy, nz = z + dz;
                const key = `${nx},${ny},${nz}`;
                if (!occupied.has(key) && ny >= 0 && (ny === 0 || occupied.has(`${nx},${ny-1},${nz}`))) {
                    occupied.add(key);
                    queue.push(key);
                }
            }
        }
    }
    
    function adjustCameraToFitBlocks() {
        if (!blocks || blocks.length === 0 || !controls) return;

        const box = new THREE.Box3();
        blocks.forEach(block => box.expandByObject(block));
        
        if (box.isEmpty()) return;

        const center = new THREE.Vector3();
        box.getCenter(center);

        const size = new THREE.Vector3();
        box.getSize(size);

        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let distance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
        distance *= 1.4;

        distance = Math.max(15, Math.min(50, distance));

        const direction = new THREE.Vector3();
        camera.position.sub(controls.target).normalize();
        if (direction.length() === 0) {
            direction.set(0.5, 0.5, 1).normalize();
        }

        const newPosition = new THREE.Vector3().copy(center).add(direction.multiplyScalar(distance));

        gsap.to(controls.target, {
            x: center.x, y: center.y, z: center.z,
            duration: 1, ease: 'power3.inOut'
        });

        gsap.to(camera.position, {
            x: newPosition.x, y: newPosition.y, z: newPosition.z,
            duration: 1, ease: 'power3.inOut'
        });
    }

    function createBlock(x, y, z, index, type) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        let material;
        const settings = difficultySettings[currentDifficulty];
        
        switch(type) {
            case 'bonus':
                material = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800, metalness: 0.8, roughness: 0.2 });
                break;
            default:
                const color = new THREE.Color(settings.colors[Math.floor(Math.random() * settings.colors.length)]);
                material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.2, roughness: 0.8 });
        }
        
        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true;
        cube.receiveShadow = true;
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
        const blockGroup = new THREE.Group();
        blockGroup.add(cube);
        blockGroup.add(line);
        
        blockGroup.position.set(x, y + 5.5, z);
        
        blockGroup.userData.type = type;
        blockGroup.scale.set(0,0,0);
        gsap.to(blockGroup.scale, { x: 1, y: 1, z: 1, duration: 0.5, delay: index * 0.01, ease: "back.out(1.7)" });
        return blockGroup;
    }

    function animate() {
      if (!renderer) return;
      requestAnimationFrame(animate);

      // 変更箇所: ユーザー操作がない場合に自動回転
      if (controls && gameState === 'playing') {
          const currentTime = Date.now();
          if (currentTime - lastUserInteractionTime > 5000) {
              controls.autoRotate = true;
              controls.autoRotateSpeed = 2.0;
          } else {
              controls.autoRotate = false;
          }
      } else if (controls) {
          controls.autoRotate = false;
      }

      if (controls) controls.update();
      renderer.render(scene, camera);
    }
    
    function nextProblem() {
        gameState = 'playing';
        currentAnswerString = "";
        elements.result.textContent = "";
        generateBlocks();
        adjustCameraToFitBlocks();
        if (gameMode === 'time-attack') {
            startTimer();
        }
        updateUI();
        // 変更箇所: 問題開始時にユーザー操作時間をリセット
        lastUserInteractionTime = Date.now();
    }
    
    function startTimer() {
        clearInterval(gameTimer);
        timeRemaining = difficultySettings[currentDifficulty].time;
        updateTimer();
        gameTimer = setInterval(() => {
            if (gameState !== 'playing') return clearInterval(gameTimer);
            timeRemaining--;
            updateTimer();
            if (timeRemaining <= 0) {
                gameOver();
            }
        }, 1000);
    }

    function onSubmitAnswer() {
        if (!elements.submitBtn.classList.contains('active') || gameState !== 'playing') return;
        gameState = 'paused';
        const userAnswer = parseInt(currentAnswerString, 10);
        
        if (userAnswer === correctBlockCount) {
            const bonusPoints = blocks.filter(b => b.userData.type === 'bonus').length * 5;
            const streakBonus = currentStreak * 10;
            const points = 10 + bonusPoints + streakBonus;
            score += points;
            currentStreak++;
            bestStreak = Math.max(bestStreak, currentStreak);
            elements.result.textContent = `🎉 正解！ +${points}pts`;
            elements.result.style.color = "#4CAF50";
            playSound('correct');
            playCorrectEffect();
            setTimeout(nextProblem, 1500);
        } else {
            currentStreak = 0;
            elements.result.textContent = `❌ 残念！正解は ${correctBlockCount} 個`;
            elements.result.style.color = "#F44336";
            playSound('incorrect');
            playIncorrectEffect();
            if (gameMode === 'time-attack') {
                timeRemaining = Math.max(0, timeRemaining - 5);
                updateTimer();
            }
            setTimeout(nextProblem, 2500);
        }
        updateUI();
    }
    
    function playCorrectEffect() {
        blocks.forEach((block, i) => {
            gsap.to(block.position, { y: block.position.y + Math.random() * 5 + 5, x: block.position.x + (Math.random() - 0.5) * 5, z: block.position.z + (Math.random() - 0.5) * 5, duration: 1, delay: i * 0.01, ease: "power2.in" });
            gsap.to(block.rotation, { x: Math.random() * Math.PI * 2, y: Math.random() * Math.PI * 2, duration: 1, delay: i * 0.01 });
            gsap.to(block.scale, { x: 0, y: 0, z: 0, duration: 1, delay: i * 0.01 });
        });
    }

    function playIncorrectEffect() {
        gsap.to(camera.position, { x: `+=${Math.random() * 0.5 - 0.25}`, y:`-=${Math.random() * 0.2}`, duration: 0.1, yoyo: true, repeat: 5 });
    }

    function playSound(type) {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        switch(type) {
            case 'click':
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
                break;
            case 'correct':
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(1046.50, audioCtx.currentTime + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                break;
            case 'incorrect':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(110, audioCtx.currentTime + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                break;
            case 'gameover':
                 oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(55, audioCtx.currentTime + 1);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 1.2);
                break;
        }
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 1.2);
    }
    
    function updateUI() {
      elements.score.textContent = `💯 ${score}`;
      elements.streak.textContent = `🔥 ${currentStreak}`;
      updateAnswerDisplay();
      updateTimer();
      elements.score.style.display = gameMode === 'zen' ? 'none' : 'block';
      elements.streak.style.display = gameMode === 'zen' ? 'none' : 'block';
    }
    
    function updateTimer() {
        if (gameMode === 'zen') {
            elements.timer.textContent = "∞";
            elements.timer.style.color = "#4CAF50";
        } else {
            elements.timer.textContent = `⏰ ${timeRemaining}`;
            elements.timer.style.color = timeRemaining <= 10 ? "#F44336" : "#FFD700";
        }
    }

    function updateAnswerDisplay() {
        elements.currentAnswerDisplay.textContent = currentAnswerString || "0";
        elements.submitBtn.classList.toggle('active', currentAnswerString !== "");
    }

    function setupEventListeners() {
        document.querySelector('#start-overlay .mode-select').addEventListener('click', e => {
            if(e.target.tagName !== 'BUTTON') return;
            gameMode = e.target.dataset.mode;
            document.querySelectorAll('#start-overlay .mode-select .btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });
        document.querySelector('#start-overlay .difficulty-select').addEventListener('click', e => {
            if(e.target.tagName !== 'BUTTON') return;
            currentDifficulty = e.target.dataset.level;
            document.querySelectorAll('#start-overlay .difficulty-select .btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });
        document.querySelector('#start-overlay .start-game').addEventListener('click', startGame);
        document.querySelector('#game-overlay .restart').addEventListener('click', startGame);
        document.querySelector('#game-overlay .menu').addEventListener('click', showStartScreen);
        elements.numpad.addEventListener("click", onNumpadClick);
        elements.submitBtn.addEventListener("click", onSubmitAnswer);
        window.addEventListener("resize", onWindowResize);
        window.addEventListener('keydown', onKeyDown);

        // 変更箇所: ユーザー操作を監視するためのイベントリスナーを追加
        document.addEventListener('mousedown', () => { lastUserInteractionTime = Date.now(); });
        document.addEventListener('touchstart', () => { lastUserInteractionTime = Date.now(); });
        document.addEventListener('wheel', () => { lastUserInteractionTime = Date.now(); });
    }
    
    function onNumpadClick(event) {
        if (gameState !== 'playing' || !event.target.dataset.value) return;
        handleInput(event.target.dataset.value);
        lastUserInteractionTime = Date.now();
    }
    
    function onKeyDown(event) {
        if (gameState === 'playing') {
            if (event.key >= '0' && event.key <= '9') handleInput(event.key);
            else if (event.key === 'Enter' || event.key === '=') onSubmitAnswer();
            else if (event.key === 'Backspace') handleInput('del');
            else if (event.key.toLowerCase() === 'c') handleInput('C');
            lastUserInteractionTime = Date.now();
        }
    }
    
    function handleInput(value) {
        playSound('click');
        if (value === "C") currentAnswerString = "";
        else if (value === "del") currentAnswerString = currentAnswerString.slice(0, -1);
        else if (currentAnswerString.length < 4) currentAnswerString += value;
        updateAnswerDisplay();
    }

    function onWindowResize() {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      const particlesCanvas = document.getElementById('particles-bg');
      if (particlesCanvas) {
        particlesCanvas.width = window.innerWidth;
        particlesCanvas.height = window.innerHeight;
      }
    }
    
    function initParticles() {
      const canvas = document.getElementById('particles-bg');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const particles = [];
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: Math.random() * canvas.width, y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1, alpha: Math.random() * 0.5 + 0.1
        });
      }
      function animateParticles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
          p.x += p.vx; p.y += p.vy;
          if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
          ctx.fill();
        });
        requestAnimationFrame(animateParticles);
      }
      animateParticles();
    }

    document.addEventListener("DOMContentLoaded", initApp);
  </script>
</body>
</html>
;
      --easy-color: #4CAF50;
      --medium-color: #FF9800;
      --hard-color: #F44336;
      --extreme-color: #9C27B0;
    }
    
    html, body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #1d2b64 0%, #0d0d20 100%);
      font-family: 'Arial', sans-serif;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    #particles-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }
    
    #gameContainer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
    }

    #ui-top, #ui-bottom {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      pointer-events: none;
      max-width: 350px;
      width: 95%;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #ui-top {
        top: 10px;
        opacity: 0;
        transform: translate(-50%, -50px);
        transition: opacity 0.5s ease, transform 0.5s ease;
    }
    #ui-bottom {
        bottom: 10px;
        opacity: 0;
        transform: translate(-50%, 50px);
        transition: opacity 0.5s ease, transform 0.5s ease;
    }
    #ui-top.visible, #ui-bottom.visible {
        opacity: 1;
        transform: translate(-50%, 0);
    }
    #ui-top > *, #ui-bottom > * {
        pointer-events: auto;
    }

    #ui-top h1 {
      margin: 0;
      font-size: 2.5em;
      background: linear-gradient(45deg, var(--glow-color), #FFA500);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      animation: glow 2s ease-in-out infinite alternate;
      text-align: center;
    }
    
    @keyframes glow {
      from { filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5)); }
      to { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
    }

    .game-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .btn {
      padding: 8px 16px;
      border: 2px solid transparent;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
      font-size: 0.9em;
      color: white;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }

    .difficulty-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .difficulty-btn.easy { background: var(--easy-color); }
    .difficulty-btn.medium { background: var(--medium-color); }
    .difficulty-btn.hard { background: var(--hard-color); }
    .difficulty-btn.extreme { background: var(--extreme-color); }
    
    .btn.active {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.2);
    }
    .difficulty-btn.active {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
      border-color: var(--glow-color);
    }
    .difficulty-btn.easy.active { background: var(--easy-color); }
    .difficulty-btn.medium.active { background: var(--medium-color); }
    .difficulty-btn.hard.active { background: var(--hard-color); }
    .difficulty-btn.extreme.active { background: var(--extreme-color); }

    #game-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1.1em;
      font-weight: bold;
    }
    
    #score, #timer {
      color: var(--glow-color);
      font-size: 1.3em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    #streak {
      color: var(--easy-color);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    #answerDisplayContainer {
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        padding: 10px 20px;
        text-align: center;
        backdrop-filter: blur(5px);
    }
    #currentAnswerDisplay {
        font-size: 3em;
        font-weight: bold;
        color: var(--glow-color);
        text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
        min-height: 1.2em;
    }

    /* 変更箇所: #numpadのサイズを縮小 */
    #numpad {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        justify-content: center;
        /* 追加: numpadの幅を制限 */
        max-width: 250px; 
        margin: 0 auto;
    }
    #numpad button {
        height: 50px;
        font-size: 1.8em;
        border: none;
        background: rgba(255, 255, 255, 0.4);
        color: white;
        cursor: pointer;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.2s ease;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        /* 追加: ボタンのサイズ調整 */
        height: 40px;
        font-size: 1.5em;
    }
    #numpad button:hover {
        background: rgba(255, 255, 255, 0.6);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #numpad button:active {
        transform: translateY(0);
    }
    #numpad button.action-btn {
        background: rgba(255, 193, 7, 0.3);
        border-color: rgba(255, 193, 7, 0.5);
    }
    
    #submitBtn {
      font-size: 1.8em;
      padding: 12px 30px;
      background: linear-gradient(45deg, var(--easy-color), #45a049);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      opacity: 0.6;
      pointer-events: none;
      width: 100%;
    }
    #submitBtn.active {
        opacity: 1;
        pointer-events: auto;
    }
    #submitBtn:hover.active {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }

    #result {
      font-size: 1.4em;
      font-weight: bold;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      min-height: 1.6em;
      animation: pulse 0.5s ease-in-out;
    }
    
    @keyframes pulse {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-content {
        background: rgba(255, 255, 255, 0.1);
        padding: 40px;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        transform: scale(0.8);
        transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .overlay.visible .overlay-content {
        transform: scale(1);
    }

    .overlay h2 {
      font-size: 4em;
      color: var(--glow-color);
      text-shadow: 4px 4px 8px rgba(0,0,0,0.7);
      margin: 0 0 20px 0;
    }
    
    .overlay p {
      font-size: 1.5em;
      margin: 10px 0;
    }
    
    .overlay-buttons {
      display: flex;
      gap: 20px;
      margin-top: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .overlay-buttons .btn {
      padding: 15px 30px;
      font-size: 1.2em;
      border-radius: 30px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .overlay-buttons .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }
    
    .overlay-buttons .restart { background: var(--easy-color); }
    .overlay-buttons .menu { background: var(--hard-color); }
    .overlay-buttons .start-game { background: var(--easy-color); }
    
    #start-overlay .mode-select {
        margin-bottom: 20px;
    }
    #start-overlay .difficulty-select {
        margin-bottom: 20px;
    }
    #start-overlay .mode-select .btn.active {
        background: var(--easy-color);
        box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        border-color: var(--glow-color);
    }

    @media (max-width: 768px) {
        #ui-top, #ui-bottom {
            max-width: 95%; 
        }
        #ui-top h1 {
            font-size: 1.8em;
        }
        .overlay h2 {
            font-size: 3em;
        }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
</head>
<body>
  <canvas id="particles-bg"></canvas>
  <div id="gameContainer"></div>

  <div id="ui-top">
    <h1>✨ 積み木マスター ✨</h1>
    <div class="game-panel">
      <div id="game-info">
        <div id="timer">⏰ --</div>
        <div id="score">💯 0</div>
        <div id="streak">🔥 0</div>
      </div>
    </div>
  </div>

  <div id="ui-bottom">
    <div class="game-panel">
      <div id="answerDisplayContainer">
        <div id="currentAnswerDisplay">0</div>
      </div>
      <div id="numpad">
        <button data-value="7">7</button><button data-value="8">8</button><button data-value="9">9</button>
        <button data-value="4">4</button><button data-value="5">5</button><button data-value="6">6</button>
        <button data-value="1">1</button><button data-value="2">2</button><button data-value="3">3</button>
        <button data-value="C" class="action-btn">C</button><button data-value="0">0</button><button data-value="del" class="action-btn">←</button>
      </div>
      <button id="submitBtn">🎯 答える</button>
    </div>
    <div id="result"></div>
  </div>

  <div id="start-overlay" class="overlay">
    <div class="overlay-content">
        <h2>積み木マスター</h2>
        <p>ゲームモードを選んでください</p>
        <div class="mode-select overlay-buttons">
            <button class="btn active" data-mode="time-attack">タイムアタック</button>
            <button class="btn" data-mode="zen">禅モード</button>
        </div>
        <p>難易度を選んでください</p>
        <div class="difficulty-select difficulty-controls overlay-buttons">
            <button class="btn difficulty-btn easy active" data-level="easy">初級</button>
            <button class="btn difficulty-btn medium" data-level="medium">中級</button>
            <button class="btn difficulty-btn hard" data-level="hard">上級</button>
            <button class="btn difficulty-btn extreme" data-level="extreme">極限</button>
        </div>
        <div class="overlay-buttons">
            <button class="btn start-game">🚀 ゲーム開始</button>
        </div>
    </div>
  </div>

  <div id="game-overlay" class="overlay">
    <div class="overlay-content">
      <h2 id="overlay-title">ゲームオーバー</h2>
      <p id="overlay-score">スコア: 0</p>
      <p id="overlay-streak">最高連続正解: 0</p>
      <div class="overlay-buttons">
        <button class="btn restart">再挑戦</button>
        <button class="btn menu">メニューに戻る</button>
      </div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, controls;
    let blocks = [];
    let correctBlockCount;
    let gameState = 'start';
    let gameMode = 'time-attack';
    let currentDifficulty = 'easy';

    let score = 0;
    let currentAnswerString = "";
    let currentStreak = 0;
    let bestStreak = 0;
    let timeRemaining = 30;
    let gameTimer;
    
    let audioCtx;

    const difficultySettings = {
      easy:   { min: 5,  max: 15,  time: 60, colors: ['#4CAF50', '#8BC34A'], specialBlockChance: 0.1 },
      medium: { min: 10, max: 50,  time: 45, colors: ['#FF9800', '#FFC107'], specialBlockChance: 0.2 },
      hard:   { min: 30, max: 100, time: 30, colors: ['#F44336', '#E91E63'], specialBlockChance: 0.3 },
      extreme:{ min: 50, max: 200, time: 20, colors: ['#9C27B0', '#673AB7'], specialBlockChance: 0.4 }
    };

    const elements = {
      uiTop: document.getElementById('ui-top'),
      uiBottom: document.getElementById('ui-bottom'),
      result: document.getElementById("result"),
      score: document.getElementById("score"),
      currentAnswerDisplay: document.getElementById("currentAnswerDisplay"),
      numpad: document.getElementById("numpad"),
      submitBtn: document.getElementById("submitBtn"),
      timer: document.getElementById("timer"),
      streak: document.getElementById("streak"),
      startOverlay: document.getElementById('start-overlay'),
      gameOverlay: document.getElementById('game-overlay'),
      overlayTitle: document.getElementById('overlay-title'),
      overlayScore: document.getElementById('overlay-score'),
      overlayStreak: document.getElementById('overlay-streak'),
    };
    
    function initApp() {
        initParticles();
        setupEventListeners();
        showStartScreen();
    }

    function startGame() {
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) { console.error("Web Audio API is not supported in this browser."); }
        }
        elements.startOverlay.classList.remove('visible');
        elements.uiTop.classList.add('visible');
        elements.uiBottom.classList.add('visible');
        gameState = 'playing';
        resetStats();
        initThreeJS();
        nextProblem();
    }
    
    function gameOver() {
        gameState = 'gameover';
        clearInterval(gameTimer);
        playSound('gameover');
        
        if (gameMode === 'zen') {
            elements.overlayTitle.textContent = "ゲーム終了";
            elements.overlayScore.style.display = 'none';
            elements.overlayStreak.style.display = 'none';
            document.querySelector('#game-overlay .restart').style.display = 'none';
        } else {
            elements.overlayTitle.textContent = "ゲームオーバー";
            elements.overlayScore.style.display = 'block';
            elements.overlayStreak.style.display = 'block';
            document.querySelector('#game-overlay .restart').style.display = 'inline-block';
            elements.overlayScore.textContent = `スコア: ${score}`;
            elements.overlayStreak.textContent = `最高連続正解: ${bestStreak}`;
        }
        elements.gameOverlay.classList.add('visible');
        elements.uiTop.classList.remove('visible');
        elements.uiBottom.classList.remove('visible');
    }
    
    function showStartScreen() {
        gameState = 'start';
        cleanUpThreeJS();
        elements.gameOverlay.classList.remove('visible');
        elements.startOverlay.classList.add('visible');
        elements.uiTop.classList.remove('visible');
        elements.uiBottom.classList.remove('visible');
    }

    function resetStats() {
        score = 0;
        currentStreak = 0;
        bestStreak = 0;
        currentAnswerString = "";
        updateUI();
    }

    function initThreeJS() {
        cleanUpThreeJS();
        const container = document.getElementById("gameContainer");
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 8, 12);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        scene.add(dirLight);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        animate();
    }

    function cleanUpThreeJS() {
        if (!scene) return;
        scene.traverse(object => {
            if (object.isMesh || object.isLineSegments) {
                if(object.geometry) object.geometry.dispose();
                if(object.material) {
                  if (Array.isArray(object.material)) {
                      object.material.forEach(material => material.dispose());
                  } else {
                      object.material.dispose();
                  }
                }
            }
        });
        if (renderer) {
            renderer.dispose();
            const container = document.getElementById("gameContainer");
            if (renderer.domElement && container.contains(renderer.domElement)) {
                container.removeChild(renderer.domElement);
            }
        }
        scene = null; renderer = null; camera = null; controls = null;
    }

    function generateBlocks() {
        blocks.forEach(block => scene.remove(block));
        blocks = [];
        correctBlockCount = 0;
        
        const settings = difficultySettings[currentDifficulty];
        const totalBlockCount = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min;
        const occupied = new Set();
        const queue = ['0,0,0']; 
        occupied.add('0,0,0');
        
        let created = 0;
        while(queue.length > 0 && created < totalBlockCount) {
            const current = queue.shift();
            if (!current) continue;
            const [x, y, z] = current.split(',').map(Number);
            
            let type = 'normal';
            if (Math.random() < settings.specialBlockChance) {
                type = 'bonus';
            }
            
            const blockGroup = createBlock(x, y, z, created, type);
            blocks.push(blockGroup);
            scene.add(blockGroup);
            correctBlockCount++;
            created++;
            
            const directions = [[1,0,0], [-1,0,0], [0,1,0], [0,0,1], [0,0,-1]].sort(() => Math.random() - 0.5);
            for(const [dx, dy, dz] of directions) {
                const nx = x + dx, ny = y + dy, nz = z + dz;
                const key = `${nx},${ny},${nz}`;
                if (!occupied.has(key) && ny >= 0 && (ny === 0 || occupied.has(`${nx},${ny-1},${nz}`))) {
                    occupied.add(key);
                    queue.push(key);
                }
            }
        }
    }
    
    function adjustCameraToFitBlocks() {
        if (!blocks || blocks.length === 0 || !controls) return;

        const box = new THREE.Box3();
        blocks.forEach(block => box.expandByObject(block));
        
        if (box.isEmpty()) return;

        const center = new THREE.Vector3();
        box.getCenter(center);

        const size = new THREE.Vector3();
        box.getSize(size);

        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let distance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
        distance *= 1.4;

        distance = Math.max(15, Math.min(50, distance));

        const direction = new THREE.Vector3();
        camera.position.sub(controls.target).normalize();
        if (direction.length() === 0) {
            direction.set(0.5, 0.5, 1).normalize();
        }

        const newPosition = new THREE.Vector3().copy(center).add(direction.multiplyScalar(distance));

        gsap.to(controls.target, {
            x: center.x, y: center.y, z: center.z,
            duration: 1, ease: 'power3.inOut'
        });

        gsap.to(camera.position, {
            x: newPosition.x, y: newPosition.y, z: newPosition.z,
            duration: 1, ease: 'power3.inOut'
        });
    }

    function createBlock(x, y, z, index, type) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        let material;
        const settings = difficultySettings[currentDifficulty];
        
        switch(type) {
            case 'bonus':
                material = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800, metalness: 0.8, roughness: 0.2 });
                break;
            default:
                const color = new THREE.Color(settings.colors[Math.floor(Math.random() * settings.colors.length)]);
                material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.2, roughness: 0.8 });
        }
        
        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true;
        cube.receiveShadow = true;
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
        const blockGroup = new THREE.Group();
        blockGroup.add(cube);
        blockGroup.add(line);
        
        // ★修正: Y座標に5を加えることで、全体の表示位置を上に移動
        blockGroup.position.set(x, y + 5.5, z);
        
        blockGroup.userData.type = type;
        blockGroup.scale.set(0,0,0);
        gsap.to(blockGroup.scale, { x: 1, y: 1, z: 1, duration: 0.5, delay: index * 0.01, ease: "back.out(1.7)" });
        return blockGroup;
    }

    function animate() {
      if (!renderer) return;
      requestAnimationFrame(animate);
      if (controls) controls.update();
      renderer.render(scene, camera);
    }
    
    function nextProblem() {
        gameState = 'playing';
        currentAnswerString = "";
        elements.result.textContent = "";
        generateBlocks();
        adjustCameraToFitBlocks();
        if (gameMode === 'time-attack') {
            startTimer();
        }
        updateUI();
    }
    
    function startTimer() {
        clearInterval(gameTimer);
        timeRemaining = difficultySettings[currentDifficulty].time;
        updateTimer();
        gameTimer = setInterval(() => {
            if (gameState !== 'playing') return clearInterval(gameTimer);
            timeRemaining--;
            updateTimer();
            if (timeRemaining <= 0) {
                gameOver();
            }
        }, 1000);
    }

    function onSubmitAnswer() {
        if (!elements.submitBtn.classList.contains('active') || gameState !== 'playing') return;
        gameState = 'paused';
        const userAnswer = parseInt(currentAnswerString, 10);
        
        if (userAnswer === correctBlockCount) {
            const bonusPoints = blocks.filter(b => b.userData.type === 'bonus').length * 5;
            const streakBonus = currentStreak * 10;
            const points = 10 + bonusPoints + streakBonus;
            score += points;
            currentStreak++;
            bestStreak = Math.max(bestStreak, currentStreak);
            elements.result.textContent = `🎉 正解！ +${points}pts`;
            elements.result.style.color = "#4CAF50";
            playSound('correct');
            playCorrectEffect();
            setTimeout(nextProblem, 1500);
        } else {
            currentStreak = 0;
            elements.result.textContent = `❌ 残念！正解は ${correctBlockCount} 個`;
            elements.result.style.color = "#F44336";
            playSound('incorrect');
            playIncorrectEffect();
            if (gameMode === 'time-attack') {
                timeRemaining = Math.max(0, timeRemaining - 5);
                updateTimer();
            }
            setTimeout(nextProblem, 2500);
        }
        updateUI();
    }
    
    function playCorrectEffect() {
        blocks.forEach((block, i) => {
            gsap.to(block.position, { y: block.position.y + Math.random() * 5 + 5, x: block.position.x + (Math.random() - 0.5) * 5, z: block.position.z + (Math.random() - 0.5) * 5, duration: 1, delay: i * 0.01, ease: "power2.in" });
            gsap.to(block.rotation, { x: Math.random() * Math.PI * 2, y: Math.random() * Math.PI * 2, duration: 1, delay: i * 0.01 });
            gsap.to(block.scale, { x: 0, y: 0, z: 0, duration: 1, delay: i * 0.01 });
        });
    }

    function playIncorrectEffect() {
        gsap.to(camera.position, { x: `+=${Math.random() * 0.5 - 0.25}`, y:`-=${Math.random() * 0.2}`, duration: 0.1, yoyo: true, repeat: 5 });
    }

    function playSound(type) {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        switch(type) {
            case 'click':
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
                break;
            case 'correct':
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(1046.50, audioCtx.currentTime + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                break;
            case 'incorrect':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(110, audioCtx.currentTime + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                break;
            case 'gameover':
                 oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(55, audioCtx.currentTime + 1);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 1.2);
                break;
        }
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 1.2);
    }
    
    function updateUI() {
      elements.score.textContent = `💯 ${score}`;
      elements.streak.textContent = `🔥 ${currentStreak}`;
      updateAnswerDisplay();
      updateTimer();
      elements.score.style.display = gameMode === 'zen' ? 'none' : 'block';
      elements.streak.style.display = gameMode === 'zen' ? 'none' : 'block';
    }
    
    function updateTimer() {
        if (gameMode === 'zen') {
            elements.timer.textContent = "∞";
            elements.timer.style.color = "#4CAF50";
        } else {
            elements.timer.textContent = `⏰ ${timeRemaining}`;
            elements.timer.style.color = timeRemaining <= 10 ? "#F44336" : "#FFD700";
        }
    }

    function updateAnswerDisplay() {
        elements.currentAnswerDisplay.textContent = currentAnswerString || "0";
        elements.submitBtn.classList.toggle('active', currentAnswerString !== "");
    }

    function setupEventListeners() {
        document.querySelector('#start-overlay .mode-select').addEventListener('click', e => {
            if(e.target.tagName !== 'BUTTON') return;
            gameMode = e.target.dataset.mode;
            document.querySelectorAll('#start-overlay .mode-select .btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });
        document.querySelector('#start-overlay .difficulty-select').addEventListener('click', e => {
            if(e.target.tagName !== 'BUTTON') return;
            currentDifficulty = e.target.dataset.level;
            document.querySelectorAll('#start-overlay .difficulty-select .btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });
        document.querySelector('#start-overlay .start-game').addEventListener('click', startGame);
        document.querySelector('#game-overlay .restart').addEventListener('click', startGame);
        document.querySelector('#game-overlay .menu').addEventListener('click', showStartScreen);
        elements.numpad.addEventListener("click", onNumpadClick);
        elements.submitBtn.addEventListener("click", onSubmitAnswer);
        window.addEventListener("resize", onWindowResize);
        window.addEventListener('keydown', onKeyDown);
    }
    
    function onNumpadClick(event) {
        if (gameState !== 'playing' || !event.target.dataset.value) return;
        handleInput(event.target.dataset.value);
    }
    
    function onKeyDown(event) {
        if (gameState === 'playing') {
            if (event.key >= '0' && event.key <= '9') handleInput(event.key);
            else if (event.key === 'Enter' || event.key === '=') onSubmitAnswer();
            else if (event.key === 'Backspace') handleInput('del');
            else if (event.key.toLowerCase() === 'c') handleInput('C');
        }
    }
    
    function handleInput(value) {
        playSound('click');
        if (value === "C") currentAnswerString = "";
        else if (value === "del") currentAnswerString = currentAnswerString.slice(0, -1);
        else if (currentAnswerString.length < 4) currentAnswerString += value;
        updateAnswerDisplay();
    }

    function onWindowResize() {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      const particlesCanvas = document.getElementById('particles-bg');
      if (particlesCanvas) {
        particlesCanvas.width = window.innerWidth;
        particlesCanvas.height = window.innerHeight;
      }
    }
    
    function initParticles() {
      const canvas = document.getElementById('particles-bg');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const particles = [];
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: Math.random() * canvas.width, y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1, alpha: Math.random() * 0.5 + 0.1
        });
      }
      function animateParticles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
          p.x += p.vx; p.y += p.vy;
          if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
          ctx.fill();
        });
        requestAnimationFrame(animateParticles);
      }
      animateParticles();
    }

    document.addEventListener("DOMContentLoaded", initApp);
  </script>
</body>
</html>
