<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Á©ç„ÅøÊú®„Éû„Çπ„Çø„Éº - Compact Remastered</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    :root {
      --glow-color: #FFD700;
      --easy-color: #4CAF50;
      --medium-color: #FF9800;
      --hard-color: #F44336;
      --extreme-color: #9C27B0;
    }
    
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #1d2b64 0%, #0d0d20 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: white;
      touch-action: none; /* ÂÖ®‰Ωì„ÅÆ„Çπ„ÇØ„É≠„Éº„É´„Éª„Ç∫„Éº„É†„ÇíÁ¶ÅÊ≠¢ */
    }
    
    #particles-bg, #gameContainer {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
    }

    /* UI„É¨„Ç§„Ç¢„Ç¶„Éà - Á∏¶„Å´‰∏¶„Åπ„Çã */
    #ui-wrapper {
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      height: 100%;
      padding: 10px;
      box-sizing: border-box;
      pointer-events: none;
    }

    #ui-top, #ui-bottom {
      pointer-events: auto;
      width: 100%;
      max-width: 400px;
      margin: 0 auto;
    }

    h1 {
      margin: 0; font-size: 1.4em; text-align: center;
      background: linear-gradient(45deg, var(--glow-color), #FFA500);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }

    .game-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    #game-info {
      display: flex; justify-content: space-around;
      font-size: 1em; font-weight: bold;
    }

    #answerDisplayContainer {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      margin-bottom: 8px;
      text-align: center;
    }
    #currentAnswerDisplay {
      font-size: 2.2em; font-weight: bold;
      color: var(--glow-color); height: 1.2em;
    }

    /* „ÉÜ„É≥„Ç≠„Éº„Çí„Çà„Çä„Ç≥„É≥„Éë„ÇØ„Éà„Å´ */
    #numpad {
      display: grid; grid-template-columns: repeat(3, 1fr);
      gap: 6px; margin-bottom: 8px;
    }
    #numpad button {
      height: 44px; /* Êåá„ÅßÊäº„Åó„ÇÑ„Åô„ÅÑÊúÄÂ∞è„Çµ„Ç§„Ç∫ */
      font-size: 1.4em; border: none;
      background: rgba(255, 255, 255, 0.2);
      color: white; border-radius: 8px;
      font-weight: bold; touch-action: manipulation;
    }
    #numpad button:active { background: rgba(255, 255, 255, 0.5); }
    #numpad button.action-btn { background: rgba(255, 255, 255, 0.1); }

    #submitBtn {
      width: 100%; height: 50px; font-size: 1.3em;
      background: linear-gradient(45deg, var(--easy-color), #45a049);
      color: white; border: none; border-radius: 25px;
      font-weight: bold; opacity: 0.5; pointer-events: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    #submitBtn.active { opacity: 1; pointer-events: auto; }

    #result {
      height: 1.4em; text-align: center; font-weight: bold; margin-top: 4px;
    }

    /* „Ç™„Éº„Éê„Éº„É¨„Ç§„ÅÆË®≠ÂÆö */
    .overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.85);
      z-index: 100; display: flex; align-items: center; justify-content: center;
      opacity: 0; pointer-events: none; transition: 0.3s;
    }
    .overlay.visible { opacity: 1; pointer-events: auto; }
    .overlay-content {
      width: 85%; max-width: 320px; text-align: center;
      background: rgba(255,255,255,0.1); padding: 20px; border-radius: 20px;
    }
    .overlay-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
    .btn {
      padding: 10px; border: none; border-radius: 10px;
      color: white; font-weight: bold; cursor: pointer;
    }
    .btn-full { grid-column: span 2; padding: 15px; font-size: 1.1em; }
    .difficulty-select { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 10px 0; }
    .difficulty-btn.easy { background: var(--easy-color); }
    .difficulty-btn.medium { background: var(--medium-color); }
    .difficulty-btn.hard { background: var(--hard-color); }
    .difficulty-btn.extreme { background: var(--extreme-color); }
    .active { outline: 3px solid white; transform: scale(1.02); }
  </style>
</head>
<body>
  <canvas id="particles-bg"></canvas>
  <div id="gameContainer"></div>

  <div id="ui-wrapper">
    <div id="ui-top">
      <h1>‚ú® Á©ç„ÅøÊú®„Éû„Çπ„Çø„Éº ‚ú®</h1>
      <div class="game-panel">
        <div id="game-info">
          <div id="timer">‚è∞ --</div>
          <div id="score">üíØ 0</div>
          <div id="streak">üî• 0</div>
        </div>
      </div>
    </div>

    <div id="ui-bottom">
      <div id="result"></div>
      <div class="game-panel">
        <div id="answerDisplayContainer">
          <div id="currentAnswerDisplay">0</div>
        </div>
        <div id="numpad">
          <button data-value="7">7</button><button data-value="8">8</button><button data-value="9">9</button>
          <button data-value="4">4</button><button data-value="5">5</button><button data-value="6">6</button>
          <button data-value="1">1</button><button data-value="2">2</button><button data-value="3">3</button>
          <button data-value="C" class="action-btn">C</button><button data-value="0">0</button><button data-value="del" class="action-btn">‚Üê</button>
        </div>
        <button id="submitBtn">üéØ Á≠î„Åà„Çã</button>
      </div>
    </div>
  </div>

  <div id="start-overlay" class="overlay visible">
    <div class="overlay-content">
      <h2>MENU</h2>
      <p>„É¢„Éº„ÉâÈÅ∏Êäû</p>
      <div class="mode-select overlay-buttons">
        <button class="btn active" style="background:#555" data-mode="time-attack">„Çø„Ç§„É†„Ç¢„Çø„ÉÉ„ÇØ</button>
        <button class="btn" style="background:#555" data-mode="zen">Á¶Ö„É¢„Éº„Éâ</button>
      </div>
      <p>Èõ£ÊòìÂ∫¶ÈÅ∏Êäû</p>
      <div class="difficulty-select">
        <button class="btn difficulty-btn easy active" data-level="easy">ÂàùÁ¥ö</button>
        <button class="btn difficulty-btn medium" data-level="medium">‰∏≠Á¥ö</button>
        <button class="btn difficulty-btn hard" data-level="hard">‰∏äÁ¥ö</button>
        <button class="btn difficulty-btn extreme" data-level="extreme">Ê•µÈôê</button>
      </div>
      <button class="btn btn-full" style="background:var(--easy-color); margin-top:15px;" id="game-start-btn">üöÄ START</button>
    </div>
  </div>

  <div id="game-overlay" class="overlay">
    <div class="overlay-content">
      <h2 id="ov-title">RESULT</h2>
      <p id="ov-score"></p>
      <div class="overlay-buttons">
        <button class="btn btn-full" style="background:var(--easy-color)" id="btn-restart">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
        <button class="btn btn-full" style="background:#555" id="btn-menu">„É°„Éã„É•„Éº„Å∏</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

  <script>
    /** „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ **/
    let scene, camera, renderer, controls;
    let blocks = [];
    let correctBlockCount = 0;
    let gameState = 'start';
    let gameMode = 'time-attack';
    let currentDifficulty = 'easy';
    let score = 0, currentStreak = 0, timeRemaining = 30, gameTimer;
    let currentAnswerString = "";
    let audioCtx;

    const difficultySettings = {
      easy: { min: 5, max: 12, time: 60, colors: ['#64B5F6', '#81C784'], chance: 0.1 },
      medium: { min: 15, max: 40, time: 45, colors: ['#FFCA28', '#FF9800'], chance: 0.2 },
      hard: { min: 40, max: 80, time: 30, colors: ['#EF5350', '#F44336'], chance: 0.3 },
      extreme: { min: 70, max: 150, time: 20, colors: ['#9C27B0', '#673AB7'], chance: 0.4 }
    };

    /** ÂàùÊúüÂåñ **/
    function init() {
      initParticles();
      setupEvents();
      // „Ç™„Éº„Éá„Ç£„Ç™„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆ‰ΩúÊàêÊ∫ñÂÇôÔºà„É¶„Éº„Ç∂„ÉºÊìç‰Ωú„ÅßÈñãÂßãÔºâ
      window.addEventListener('touchstart', () => { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }, {once: true});
    }

    function setupEvents() {
      document.getElementById('game-start-btn').onclick = startGame;
      document.getElementById('btn-restart').onclick = startGame;
      document.getElementById('btn-menu').onclick = () => location.reload();
      document.getElementById('submitBtn').onclick = checkAnswer;
      
      // „É¢„Éº„Éâ/Èõ£ÊòìÂ∫¶Âàá„ÇäÊõø„Åà
      document.querySelectorAll('.mode-select .btn, .difficulty-select .btn').forEach(btn => {
        btn.onclick = (e) => {
          const parent = e.target.parentElement;
          parent.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          if(e.target.dataset.mode) gameMode = e.target.dataset.mode;
          if(e.target.dataset.level) currentDifficulty = e.target.dataset.level;
        };
      });

      // „ÉÜ„É≥„Ç≠„Éº
      document.getElementById('numpad').onclick = (e) => {
        if(e.target.tagName !== 'BUTTON' || gameState !== 'playing') return;
        const val = e.target.dataset.value;
        playSound('click');
        if(val === 'C') currentAnswerString = "";
        else if(val === 'del') currentAnswerString = currentAnswerString.slice(0, -1);
        else if(currentAnswerString.length < 4) currentAnswerString += val;
        updateUI();
      };
    }

    /** 3D„Ç®„É≥„Ç∏„É≥Èñ¢ÈÄ£ **/
    function startGame() {
      document.querySelectorAll('.overlay').forEach(o => o.classList.remove('visible'));
      score = 0; currentStreak = 0;
      gameState = 'playing';
      
      if(!renderer) {
        initThreeJS();
      }
      nextProblem();
    }

    function initThreeJS() {
      const container = document.getElementById("gameContainer");
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7);
      light.castShadow = true;
      scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.maxDistance = 50;
      controls.minDistance = 10;
      controls.maxPolarAngle = Math.PI / 2;

      animate();
    }

    function clearBlocks() {
      blocks.forEach(b => {
        b.traverse(node => {
          if (node.isMesh) {
            node.geometry.dispose();
            if (Array.isArray(node.material)) node.material.forEach(m => m.dispose());
            else node.material.dispose();
          }
        });
        scene.remove(b);
      });
      blocks = [];
    }

    function generateBlocks() {
      clearBlocks();
      const set = difficultySettings[currentDifficulty];
      const count = Math.floor(Math.random() * (set.max - set.min + 1)) + set.min;
      correctBlockCount = 0;
      
      const occupied = new Set();
      const queue = [[0,0,0]];
      occupied.add('0,0,0');

      for(let i=0; i<count; i++) {
        const pos = queue.shift() || [0,0,0];
        const block = createMesh(pos[0], pos[1], pos[2], i, set);
        blocks.push(block);
        scene.add(block);
        correctBlockCount++;

        // Èö£Êé•ÂÄôË£ú„ÇíËøΩÂä†
        [[1,0,0],[-1,0,0],[0,1,0],[0,0,1],[0,0,-1]].forEach(d => {
          const np = [pos[0]+d[0], pos[1]+d[1], pos[2]+d[2]];
          const key = np.join(',');
          if(!occupied.has(key) && np[1] >= 0) {
            occupied.add(key);
            queue.splice(Math.floor(Math.random()*queue.length), 0, np);
          }
        });
      }
      adjustCamera();
    }

    function createMesh(x, y, z, i, set) {
      const geo = new THREE.BoxGeometry(1, 1, 1);
      const isBonus = Math.random() < set.chance;
      const color = isBonus ? 0xffd700 : set.colors[Math.floor(Math.random()*set.colors.length)];
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = mesh.receiveShadow = true;

      // Á∏ÅÂèñ„Çä
      const edge = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({color:0x000000}));
      
      const group = new THREE.Group();
      group.add(mesh, edge);
      group.position.set(x, y, z);
      group.scale.set(0,0,0);
      gsap.to(group.scale, {x:1, y:1, z:1, duration:0.4, delay: i*0.01, ease:"back.out"});
      return group;
    }

    function adjustCamera() {
      const box = new THREE.Box3();
      blocks.forEach(b => box.expandByObject(b));
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      
      const dist = Math.max(size.x, size.y, size.z) * 2.5;
      
      // UI„Åå‰∏ãÈÉ®„Å´„ÅÇ„Çã„Åü„ÇÅ„ÄÅÊ≥®Ë¶ñÁÇπÔºà„Çø„Éº„Ç≤„ÉÉ„ÉàÔºâ„ÇíÂ∞ë„Åó‰∏ã„Å´„Åö„Çâ„Åó„Å¶„ÄÅÁâ©‰Ωì„ÇíÁîªÈù¢‰∏äÈÉ®„Å´Ë°®Á§∫„Åï„Åõ„Çã
      const targetY = center.y - (size.y * 0.5); 
      
      gsap.to(camera.position, { x: center.x + dist, y: center.y + dist*0.8, z: center.z + dist, duration: 1 });
      gsap.to(controls.target, { x: center.x, y: targetY, z: center.z, duration: 1 });
    }

    /** „Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ **/
    function checkAnswer() {
      if(gameState !== 'playing') return;
      gameState = 'paused';
      const ans = parseInt(currentAnswerString);
      const resEl = document.getElementById('result');

      if(ans === correctBlockCount) {
        score += (10 + currentStreak * 5);
        currentStreak++;
        resEl.innerHTML = "<span style='color:var(--easy-color)'>Ê≠£Ëß£ÔºÅ O</span>";
        playSound('correct');
        setTimeout(nextProblem, 1000);
      } else {
        currentStreak = 0;
        resEl.innerHTML = `<span style='color:var(--hard-color)'>ÊÆãÂøµÔºÅ Ê≠£Ëß£„ÅØ ${correctBlockCount}</span>`;
        playSound('incorrect');
        if(gameMode === 'time-attack') timeRemaining -= 5;
        setTimeout(nextProblem, 2000);
      }
      updateUI();
    }

    function nextProblem() {
      if(gameMode === 'time-attack' && timeRemaining <= 0) return endGame();
      gameState = 'playing';
      currentAnswerString = "";
      document.getElementById('result').textContent = "";
      generateBlocks();
      updateUI();
      if(gameMode === 'time-attack') startTimer();
    }

    function startTimer() {
      clearInterval(gameTimer);
      if(gameMode === 'zen') return;
      gameTimer = setInterval(() => {
        timeRemaining--;
        updateUI();
        if(timeRemaining <= 0) endGame();
      }, 1000);
    }

    function endGame() {
      gameState = 'gameover';
      clearInterval(gameTimer);
      document.getElementById('ov-score').textContent = `ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}`;
      document.getElementById('game-overlay').classList.add('visible');
    }

    function updateUI() {
      document.getElementById('score').textContent = `üíØ ${score}`;
      document.getElementById('timer').textContent = gameMode === 'zen' ? "‚è∞ ‚àû" : `‚è∞ ${timeRemaining}`;
      document.getElementById('streak').textContent = `üî• ${currentStreak}`;
      document.getElementById('currentAnswerDisplay').textContent = currentAnswerString || "0";
      document.getElementById('submitBtn').classList.toggle('active', currentAnswerString.length > 0);
    }

    function animate() {
      requestAnimationFrame(animate);
      if(controls) controls.update();
      if(renderer) renderer.render(scene, camera);
    }

    function playSound(type) {
      if(!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
      if(type==='click') { osc.frequency.value = 800; gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1); }
      if(type==='correct') { osc.frequency.setValueAtTime(523, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(1046, audioCtx.currentTime+0.2); }
      if(type==='incorrect') { osc.frequency.setValueAtTime(200, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime+0.3); }
      osc.start(); osc.stop(audioCtx.currentTime + 0.3);
    }

    function initParticles() {
      const cvs = document.getElementById('particles-bg');
      const ctx = cvs.getContext('2d');
      cvs.width = window.innerWidth; cvs.height = window.innerHeight;
      const parts = Array.from({length: 50}, () => ({
        x: Math.random()*cvs.width, y: Math.random()*cvs.height,
        v: Math.random()*0.5 + 0.2
      }));
      function draw() {
        ctx.clearRect(0,0,cvs.width,cvs.height);
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        parts.forEach(p => {
          p.y -= p.v; if(p.y < 0) p.y = cvs.height;
          ctx.beginPath(); ctx.arc(p.x, p.y, 1, 0, 7); ctx.fill();
        });
        requestAnimationFrame(draw);
      }
      draw();
    }

    window.onload = init;
    window.onresize = () => {
      if(camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    };
  </script>
</body>
</html>
