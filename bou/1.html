<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>縦棒グラフ当てゲーム 豪華版</title>
  <style>
    /* 全体のデザイン */
    body {
      background: linear-gradient(135deg, #e0f2f7, #c1e4ee); /* 明るい青系グラデーション */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* モダンなフォント */
      text-align: center;
      margin: 20px;
      color: #2c3e50; /* 濃い青系のテキスト色 */
      line-height: 1.6;
    }
    /* タイマー設定 */
    #settings {
      margin: 10px auto 20px;
      display: inline-block;
      text-align: left;
      background-color: #ffffff;
      padding: 15px 25px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    fieldset {
      border: 1px solid #a7d9f0; /* 明るい青のボーダー */
      border-radius: 8px;
      padding: 10px 15px;
      margin-bottom: 10px;
      background-color: #f8fcff;
    }
    legend {
      font-weight: bold;
      color: #007bb5; /* 青 */
      padding: 0 10px;
      font-size: 16px;
    }
    label {
      margin-right: 15px;
      font-size: 15px;
      cursor: pointer;
    }
    /* 棒グラフ描画用 Canvas */
    #barCanvas {
      border: 2px solid #a7d9f0; /* 明るい青のボーダー */
      background-color: #fdfefe; /* ほぼ白 */
      display: block;
      margin: 0 auto 15px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15); /* より強い影 */
      border-radius: 10px;
    }
    /* 入力フィールド */
    #guessContainer {
      margin-bottom: 10px; /* resultDivとの間に少しスペースを */
    }
    #guessInput {
      width: 160px; /* 少し広く */
      font-size: 32px; /* 大きく */
      text-align: right;
      padding: 8px 15px; /* パディングを増やす */
      border: 2px solid #007bb5; /* 青いボーダー */
      border-radius: 8px;
      background: #fdfefe;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1); /* 内側に影 */
      transition: all 0.3s ease;
    }
    #guessInput:focus {
      outline: none;
      border-color: #0056b3; /* フォーカス時の色 */
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1), 0 0 8px rgba(0, 123, 181, 0.4);
    }

    /* 電卓風 キーパッド */
    .keypad {
      display: grid;
      grid-template-columns: repeat(3, 90px); /* キーを大きく */
      grid-gap: 15px; /* ギャップを広げる */
      justify-content: center;
      margin: 10px 0 20px;
    }
    .key {
      font-size: 36px; /* 文字を大きく */
      padding: 20px; /* パディングを増やす */
      border: none;
      border-radius: 12px; /* 角を丸く */
      background-color: #28a745; /* 緑系 */
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15); /* 影 */
    }
    /* =ボタンの色とカーソルを通常に戻す */
    .key[data-key="="] {
        background-color: #007bff; /* 青系に戻す */
        cursor: pointer; /* 通常のカーソルに戻す */
    }
    .key[data-key="C"] {
        background-color: #dc3545; /* Cボタンは赤 */
    }
    .key:hover:not(:disabled) {
      background-color: #218838; /* ホバー時の色 */
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      transform: translateY(-2px); /* 少し上に浮く */
    }
    /* =ボタンのホバー時の色を調整 */
    .key[data-key="="]:hover:not(:disabled) {
        background-color: #0056b3; /* 青系のホバー色 */
    }
    .key:active:not(:disabled) {
      background-color: #1e7e34;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transform: translateY(0);
    }
    /* =ボタンのアクティブ時の色を調整 */
    .key[data-key="="]:active:not(:disabled) {
        background-color: #004085; /* 青系のアクティブ色 */
    }
    .key:disabled {
      background-color: #b0c4de; /* 無効時の色 */
      cursor: not-allowed;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    /* その他のボタン */
    button {
      font-size: 18px; /* 大きく */
      padding: 10px 18px; /* パディングを増やす */
      border: none;
      border-radius: 8px; /* 角を丸く */
      background-color: #007bff; /* 青系 */
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      margin: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
    }
    button:hover:not(:disabled) {
      background-color: #0056b3; /* ホバー時の色 */
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      transform: translateY(-2px);
    }
    button:active:not(:disabled) {
      background-color: #004085;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transform: translateY(0);
    }
    button:disabled {
      background-color: #b0c4de;
      cursor: not-allowed;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    /* タイマー、スコア、ラウンド、コンボ表示 */
    #timerDisplay, #scoreDisplay, #highScoreDisplay {
      margin-top: 10px;
      font-size: 20px; /* 少し大きく */
      font-weight: bold;
      color: #2c3e50;
    }
    #scoreDisplay {
      margin-bottom: 10px;
      color: #34495e;
    }
    /* resultDiv のスタイルを調整 */
    #result {
      min-height: 70px; /* 高さを確保 */
      padding: 10px;
      background-color: #ecf0f1; /* 薄いグレー */
      border-radius: 8px;
      margin: 15px auto 20px; /* 下のマージンを増やす */
      max-width: 400px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      color: #333;
      font-size: 22px; /* 文字を大きく */
      font-weight: bold; /* 太字に */
    }
    .high-score-display { /* ハイスコア表示用のクラス */
        color: #e67e22; /* オレンジ色 */
        font-size: 22px;
        margin-bottom: 10px;
        display: block; /* デフォルトで表示 */
    }
    /* コンフェッティ用 Canvas（全画面オーバーレイ） */
    #confettiCanvas {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }
    /* ラウンド結果履歴のスタイル */
    #roundHistory {
        text-align: left;
        margin: 20px auto;
        padding: 15px;
        background-color: #f0f8ff;
        border: 1px solid #a7d9f0;
        border-radius: 10px;
        max-width: 450px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        display: none; /* 初期は非表示 */
    }
    #roundHistory h3 {
        color: #007bb5;
        margin-top: 0;
        border-bottom: 1px solid #a7d9f0;
        padding-bottom: 5px;
    }
    #roundHistory ul {
        list-style: none;
        padding: 0;
        max-height: 200px;
        overflow-y: auto; /* スクロール可能に */
    }
    #roundHistory li {
        padding: 5px 0;
        border-bottom: 1px dashed #e0e0e0;
        font-size: 14px;
        color: #555;
    }
    #roundHistory li:last-child {
        border-bottom: none;
    }

  </style>
</head>
<body>
  <div id="settings">
    <fieldset>
      <legend>ゲームモード / タイマー設定</legend>
      <label><input type="radio" name="timerOption" value="10">10秒</label>
      <label><input type="radio" name="timerOption" value="15" checked>15秒</label>
      <label><input type="radio" name="timerOption" value="20">20秒</label>
      <label><input type="radio" name="timerOption" value="30_challenge">30秒チャレンジ</label>
      <label><input type="radio" name="timerOption" value="60_challenge">1分チャレンジ</label>
      <label><input type="radio" name="timerOption" value="120_challenge">2分チャレンジ</label>
    </fieldset>
    <fieldset>
      <legend>棒の長さの難易度</legend>
      <label><input type="radio" name="difficultyOption" value="normal" checked>ノーマル (20-100mm)</label>
      <label><input type="radio" name="difficultyOption" value="easy">イージー (30-80mm)</label>
      <label><input type="radio" name="difficultyOption" value="hard">ハード (10-120mm)</label>
    </fieldset>
    <fieldset>
      <legend>目盛りの表示</legend>
      <label><input type="radio" name="rulerOption" value="none" checked>無し</label>
      <label><input type="radio" name="rulerOption" value="show">有り</label>
    </fieldset>
  </div>

  <canvas id="barCanvas" width="150" height="350"></canvas>

  <div id="guessContainer">
    <input type="text" id="guessInput" placeholder="0" inputmode="none" pattern="[0-9]*">
  </div>

  <div id="result"></div>

  <div class="keypad">
    <button class="key" data-key="7">7</button>
    <button class="key" data-key="8">8</button>
    <button class="key" data-key="9">9</button>
    <button class="key" data-key="4">4</button>
    <button class="key" data-key="5">5</button>
    <button class="key" data-key="6">6</button>
    <button class="key" data-key="1">1</button>
    <button class="key" data-key="2">2</button>
    <button class="key" data-key="3">3</button>
    <button class="key" data-key="C">C</button>
    <button class="key" data-key="0">0</button>
    <button class="key" data-key="=">=</button>
  </div>

  <div>
    <button id="hint">ヒント</button>
    <button id="reset">次のラウンド</button>
    <button id="showHistory">結果履歴</button>
    <button id="endGame" style="background-color: #e74c3c;">ゲーム終了</button>
  </div>

  <div id="timerDisplay">残り時間: <span id="timeLeft">15</span> 秒</div>
  <div id="highScoreDisplay" class="high-score-display">ハイスコア: <span id="highScore">0</span></div>
  <div id="30sChallengeHighScoreDisplay" class="high-score-display" style="display:none;">30秒チャレンジハイスコア: <span id="30sChallengeHighScore">0</span></div>
  <div id="60sChallengeHighScoreDisplay" class="high-score-display" style="display:none;">1分チャレンジハイスコア: <span id="60sChallengeHighScore">0</span></div>
  <div id="120sChallengeHighScoreDisplay" class="high-score-display" style="display:none;">2分チャレンジハイスコア: <span id="120sChallengeHighScore">0</span></div>
  <div id="scoreDisplay">
    スコア: <span id="score">0</span> |
    ラウンド: <span id="round">1</span> |
    コンボ: <span id="combo">0</span>
  </div>

  <div id="roundHistory">
    <h3>これまでのラウンド結果</h3>
    <ul id="historyList">
      </ul>
    <button id="clearHistory">履歴をクリア</button>
    <button id="closeHistory">閉じる</button>
  </div>

  <canvas id="confettiCanvas"></canvas>

  <script>
    // グローバル変数
    let actualLength;       // 棒の実際の長さ（mm）
    let score = 0;
    let highScore = 0; // 通常モードハイスコア
    let challengeHighScores = { // 各チャレンジモードのハイスコア
        '30s': 0,
        '60s': 0,
        '120s': 0
    };
    let currentChallengeModeKey = null; // 現在のチャレンジモードのキー (例: '30s', '60s', '120s')

    let round = 1;
    let combo = 0;
    let timeLeft = 15;
    let timerInterval = null;
    let hintUsed = false;
    let gameActive = true; // ゲームがアクティブかどうかを管理するフラグ
    let isChallengeMode = false; // チャレンジモードかどうかを判定するフラグ
    const scaleFactor = 3;  // 1mm = 3px に換算

    // サウンド関連
    const correctSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-game-success-alert-2037.mp3'); // 成功音
    const incorrectSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-failure-trombone-01.mp3'); // 失敗音
    const comboSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-1698.mp3'); // コンボ音
    const timerWarningSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-small-bell-ring-1249.mp3'); // タイマー警告音（残り5秒）
    const gameOverSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3'); // ゲームオーバー音

    // ゲーム要素の参照
    const canvas = document.getElementById('barCanvas');
    const ctx = canvas.getContext('2d');
    const guessInput = document.getElementById('guessInput');
    const timeLeftSpan = document.getElementById('timeLeft');
    const scoreSpan = document.getElementById('score');
    const roundSpan = document.getElementById('round');
    const comboSpan = document.getElementById('combo');
    const resultDiv = document.getElementById('result');
    const highScoreSpan = document.getElementById('highScore'); // 通常モードハイスコア表示用
    const challengeHighScoreDisplays = { // チャレンジモードハイスコア表示用のDOM要素をマップ
        '30s': document.getElementById('30sChallengeHighScoreDisplay').querySelector('span'),
        '60s': document.getElementById('60sChallengeHighScoreDisplay').querySelector('span'),
        '120s': document.getElementById('120sChallengeHighScoreDisplay').querySelector('span')
    };
    const challengeHighScoreContainers = { // チャレンジモードハイスコア表示用の親divをマップ
        '30s': document.getElementById('30sChallengeHighScoreDisplay'),
        '60s': document.getElementById('60sChallengeHighScoreDisplay'),
        '120s': document.getElementById('120sChallengeHighScoreDisplay')
    };

    const roundHistoryDiv = document.getElementById('roundHistory'); // 履歴表示エリア
    const historyListUl = document.getElementById('historyList'); // 履歴リスト
    const showHistoryButton = document.getElementById('showHistory');
    const clearHistoryButton = document.getElementById('clearHistory');
    const closeHistoryButton = document.getElementById('closeHistory');
    const endGameButton = document.getElementById('endGame'); // ゲーム終了ボタン
    const equalsButton = document.querySelector('.key[data-key="="]'); // =ボタンへの参照
    const timerOptionRadios = document.querySelectorAll('input[name="timerOption"]'); // タイマー設定ラジオボタン
    const difficultyOptionRadios = document.querySelectorAll('input[name="difficultyOption"]'); // 難易度設定ラジオボタン
    const rulerOptionRadios = document.querySelectorAll('input[name="rulerOption"]'); // **目盛り表示オプションラジオボタン**

    let roundResults = []; // 各ラウンドの結果を保存する配列

    // 初期化処理
    function initializeGame() {
        loadHighScores(); // 全てのハイスコアをロード
        loadRoundHistory(); // 履歴をロード
        resetGameState(); // ゲーム状態をリセット
        startRound();
    }

    // ゲームの状態をリセットする関数
    function resetGameState() {
        clearInterval(timerInterval); // タイマーを停止
        score = 0;
        round = 1;
        combo = 0;
        hintUsed = false;
        gameActive = true; // ゲームをアクティブにする
        
        const selectedTimerOptionValue = document.querySelector('input[name="timerOption"]:checked').value;
        
        // モード判定と初期タイマー値の設定
        if (selectedTimerOptionValue.endsWith('_challenge')) {
            isChallengeMode = true;
            currentChallengeModeKey = selectedTimerOptionValue.replace('_challenge', ''); // '30s', '60s', '120s'
            timeLeft = parseInt(selectedTimerOptionValue.split('_')[0]); // 例: "30_challenge" から 30 を取得
            roundSpan.style.display = 'none'; // チャレンジモードではラウンド表示を非表示に
            comboSpan.style.display = 'none'; // コンボ表示も非表示に
            document.getElementById('highScoreDisplay').style.display = 'none'; // 通常ハイスコア非表示
            // 全てのチャレンジハイスコア表示を一旦非表示にして、現在のモードのハイスコアだけ表示
            Object.values(challengeHighScoreContainers).forEach(el => el.style.display = 'none');
            if (challengeHighScoreContainers[currentChallengeModeKey]) {
                challengeHighScoreContainers[currentChallengeModeKey].style.display = 'block';
            }
        } else {
            isChallengeMode = false;
            currentChallengeModeKey = null;
            timeLeft = parseInt(selectedTimerOptionValue);
            roundSpan.style.display = 'inline';
            comboSpan.style.display = 'inline';
            document.getElementById('highScoreDisplay').style.display = 'block'; // 通常ハイスコア表示
            Object.values(challengeHighScoreContainers).forEach(el => el.style.display = 'none'); // チャレンジハイスコア非表示
        }

        scoreSpan.textContent = score;
        roundSpan.textContent = round;
        comboSpan.textContent = combo;
        timeLeftSpan.textContent = timeLeft;
        guessInput.value = "";
        resultDiv.innerHTML = "";
        document.getElementById('hint').disabled = false;
        enableKeypad();
        // キーボード入力が有効な場合、フォーカスを当てる
        guessInput.focus();
        document.getElementById('reset').textContent = isChallengeMode ? 'もう一度プレイ' : '次のラウンド';
    }


    // ハイスコアのロードと保存
    function loadHighScores() {
        const storedHighScore = localStorage.getItem('barGuessingHighScore');
        if (storedHighScore) {
            highScore = parseInt(storedHighScore, 10);
            highScoreSpan.textContent = highScore;
        }

        for (const key in challengeHighScores) {
            const storedChallengeHighScore = localStorage.getItem(`barGuessingChallengeHighScore_${key}`);
            if (storedChallengeHighScore) {
                challengeHighScores[key] = parseInt(storedChallengeHighScore, 10);
                if (challengeHighScoreDisplays[key]) {
                    challengeHighScoreDisplays[key].textContent = challengeHighScores[key];
                }
            }
        }
    }

    function saveHighScores() {
        if (isChallengeMode && currentChallengeModeKey) {
            if (score > challengeHighScores[currentChallengeModeKey]) {
                challengeHighScores[currentChallengeModeKey] = score;
                localStorage.setItem(`barGuessingChallengeHighScore_${currentChallengeModeKey}`, challengeHighScores[currentChallengeModeKey]);
                if (challengeHighScoreDisplays[currentChallengeModeKey]) {
                    challengeHighScoreDisplays[currentChallengeModeKey].textContent = challengeHighScores[currentChallengeModeKey];
                }
                resultDiv.innerHTML += `<br><strong><span style="color: #e67e22;">新記録達成！</span></strong>`;
            }
        } else {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('barGuessingHighScore', highScore);
                highScoreSpan.textContent = highScore;
            }
        }
    }

    // ラウンド履歴のロードと保存
    function loadRoundHistory() {
        const storedHistory = localStorage.getItem('barGuessingRoundHistory');
        if (storedHistory) {
            roundResults = JSON.parse(storedHistory);
            renderRoundHistory();
        }
    }

    function saveRoundHistory() {
        localStorage.setItem('barGuessingRoundHistory', JSON.stringify(roundResults));
    }

    function clearRoundHistory() {
        if (confirm('全ての履歴を削除してもよろしいですか？')) {
            roundResults = [];
            saveRoundHistory();
            renderRoundHistory();
            alert('履歴がクリアされました。');
            closeHistoryButton.click(); // 履歴ウィンドウを閉じる
        }
    }

    function renderRoundHistory() {
        historyListUl.innerHTML = ''; // リストをクリア
        if (roundResults.length === 0) {
            const li = document.createElement('li');
            li.textContent = 'まだ履歴がありません。';
            historyListUl.appendChild(li);
            return;
        }
        // 最新のものを上にするためにreverse()
        [...roundResults].reverse().forEach((result, index) => {
            const li = document.createElement('li');
            // チャレンジモードの結果表示を考慮
            const roundNumber = roundResults.length - index; // 逆順なので元のラウンド番号を計算
            const guessText = result.guess !== null ? `${result.guess}mm` : '未入力';
            const diffText = result.diff !== '時間切れ' ? `${result.diff}mm` : '時間切れ';
            li.textContent = `R${roundNumber}: 予想 ${guessText}, 実際 ${result.actual}mm, 差 ${diffText}, スコア ${result.points}点`;
            li.style.color = result.points > 0 ? '#28a745' : '#dc3545'; // スコアによって色分け
            historyListUl.appendChild(li);
        });
    }

    // 数字キーボードの操作
    function onKeypadClick(e) {
      if (!gameActive) return; // ゲームが非アクティブなら操作を受け付けない

      const key = e.target.getAttribute("data-key");
      if (key === "C") {
        guessInput.value = "";
      } else if (key === "=") {
        evaluateGuess(); // =ボタンで答え合わせ
      } else {
        let currentValue = guessInput.value;
        // 先頭が0で次の入力も0の場合は何もしない (00にならないように)
        if (currentValue === "0" && key === "0") {
            return;
        }
        // 先頭が0で次の入力が0以外の場合は、0を消して新しい数字を追加
        if (currentValue === "0" && key !== "0") {
            currentValue = key;
        } else {
            currentValue += key;
        }

        // 最大3桁に制限 (100mmを超える可能性を考慮し、最大120mmまで入力できるように3桁とする)
        if (currentValue.length > 3) {
          return;
        }
        guessInput.value = currentValue;

        // 入力が3桁になったら自動で答え合わせ（=ボタンが有効でもこの機能は残す）
        // チャレンジモードでは、入力が3桁になったら自動で答え合わせしない（ユーザーが「=」を押すまで待つ）
        if (currentValue.length === 3 && !isChallengeMode) {
          evaluateGuess();
        }
      }
    }
    document.querySelectorAll(".key").forEach(btn => {
      btn.addEventListener("click", onKeypadClick);
    });

    // キーボード入力のイベントリスナー
    guessInput.addEventListener('keydown', (e) => {
        if (!gameActive) {
            e.preventDefault(); // ゲームが非アクティブならキー入力を防ぐ
            return;
        }

        const key = e.key;
        if (key === 'Enter') {
            e.preventDefault(); // Enterキーによるフォーム送信を防ぐ
            evaluateGuess();
        } else if (key === 'Backspace') {
            // Backspaceは通常通り動作させる
        } else if (!/^\d$/.test(key)) { // 数字キー以外は入力を防ぐ
            e.preventDefault();
        } else {
            // 入力中の値が3桁になる場合はそれ以上入力させない
            if (guessInput.value.length >= 3 && key !== 'Backspace') {
                e.preventDefault();
            }
        }
    });

    // guessInputの変更イベントで、値が非数字になったらクリアする
    guessInput.addEventListener('input', (e) => {
        // 数字以外が入力された場合（ペーストなど）に対応
        if (!/^\d*$/.test(guessInput.value)) {
            guessInput.value = guessInput.value.replace(/\D/g, ''); // 数字以外を削除
        }
        // 桁数制限（3桁を超えたら切り詰める）
        if (guessInput.value.length > 3) {
            guessInput.value = guessInput.value.slice(0, 3);
        }
    });

    function disableKeypad() {
      document.querySelectorAll(".key").forEach(btn => btn.disabled = true);
      guessInput.disabled = true; // キーボード入力も無効化
    }
    function enableKeypad() {
      document.querySelectorAll(".key").forEach(btn => btn.disabled = false);
      guessInput.disabled = false; // キーボード入力も有効化
    }

    // 棒グラフの描画 (四角い棒に戻し、レンガ模様を追加、目盛り追加)
    function drawBar(animateGlow = false) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const barWidth = 80; // 棒の幅を太く
      const targetHeight = actualLength * scaleFactor;
      const x = (canvas.width - barWidth) / 2;
      const startY = canvas.height; // 下から描画開始
      let currentHeight = 0;
      let animationStartTime = null;
      const animationDuration = 300; // 初期描画アニメーション時間 (ms)
      const glowDuration = 1000; // 光るアニメーション時間 (ms)

      function animate(timestamp) {
        if (!animationStartTime) animationStartTime = timestamp;
        
        let progress;
        if (!animateGlow) { // 初期描画アニメーション
            progress = (timestamp - animationStartTime) / animationDuration;
            currentHeight = targetHeight * Math.min(progress, 1);
        } else { // 光るアニメーション
            progress = (timestamp - animationStartTime) / glowDuration;
            // 光るアニメーション中は高さ固定
            currentHeight = targetHeight; 
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height); // 再描画前にクリア

        const y = startY - currentHeight; // 棒の描画開始Y座標

        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowOffsetX = 4;
        ctx.shadowOffsetY = 4;
        ctx.shadowBlur = 6;

        // 棒の本体部分の描画
        ctx.fillStyle = '#A0522D'; // Sienna (レンガのベース色)
        ctx.fillRect(x, y, barWidth, currentHeight);

        // レンガ模様の描画
        const brickHeight = 20; // レンガの高さ
        const brickGap = 2;     // レンガの隙間
        const brickColor = '#CD5C5C'; // IndianRed (レンガの色)

        for (let i = 0; i * (brickHeight + brickGap) < currentHeight; i++) {
            let rowY = startY - (i * (brickHeight + brickGap) + brickHeight); // 下から上に描画
            
            // 描画範囲を現在の棒の高さ内に収める
            if (rowY < y) rowY = y;
            if (rowY + brickHeight > startY) rowY = startY - brickHeight;

            // 各行のレンガの開始X座標をずらす
            const offset = (i % 2 === 0) ? 0 : (barWidth / 2 - brickGap * 1.5) / 2; // 偶数行と奇数行でずらす
            
            // レンガ間の横線（レンガの上に描画されるようにループの前に移動）
            if (i > 0) {
                ctx.fillStyle = '#777'; // 隙間の色
                ctx.fillRect(x, rowY + brickHeight + brickGap, barWidth, brickGap);
            }

            // 奇数行の特殊処理（左右に半分のレンガ）
            if (i % 2 !== 0) {
                const halfBrickWidth = (barWidth - brickGap * 3) / 2;
                ctx.fillStyle = brickColor;
                ctx.fillRect(x + brickGap, rowY, halfBrickWidth, brickHeight); // 左側の半レンガ
                ctx.fillRect(x + barWidth - brickGap - halfBrickWidth, rowY, halfBrickWidth, brickHeight); // 右側の半レンガ
            } else { // 偶数行
                const fullBrickWidth = (barWidth - brickGap * 3) / 2;
                ctx.fillStyle = brickColor;
                ctx.fillRect(x + brickGap, rowY, fullBrickWidth, brickHeight); // 左のレンガ
                ctx.fillRect(x + brickGap * 2 + fullBrickWidth, rowY, fullBrickWidth, brickHeight); // 右のレンガ
                // レンガの間の縦線
                ctx.fillStyle = '#777'; // 隙間の色
                ctx.fillRect(x + barWidth / 2 - brickGap / 2, rowY, brickGap, brickHeight);
            }
        }


        // 光るエフェクト
        if (animateGlow) {
            const currentGlowProgress = (timestamp - animationStartTime) / glowDuration;
            if (currentGlowProgress >= 1) {
                ctx.restore(); // アニメーション終了時にrestoreしてシャドウを元に戻す
                // アニメーション終了後、通常の描画を完了させるために再描画
                drawBar(false);
                return; 
            }
            const glowAlpha = Math.abs(Math.sin(currentGlowProgress * Math.PI)) * 0.8; // 0から1まで変化し、元に戻る
            ctx.shadowColor = `rgba(150, 255, 150, ${glowAlpha})`; // 明るい緑色の光
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.fillStyle = `rgba(255, 255, 255, ${glowAlpha * 0.5})`; // 棒自体も少し光らせる
            ctx.fillRect(x, y, barWidth, currentHeight);
        }
        ctx.restore();

        // 目盛り線の描画 (選択された場合のみ)
        const selectedRulerOption = document.querySelector('input[name="rulerOption"]:checked').value;
        if (selectedRulerOption === 'show') {
            const rulerX = x + barWidth + 10; // 棒の右側に10px間隔を空けて配置
            const rulerWidth = 20; // 定規の幅
            const maxMillimeter = getMaxMillimeterForCurrentDifficulty(); // 現在の難易度設定の最大値

            ctx.fillStyle = '#777';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';

            // 0mmの線
            ctx.fillRect(rulerX, canvas.height - 1, rulerWidth, 1);
            ctx.fillText('0mm', rulerX + rulerWidth + 2, canvas.height);

            for (let mm = 10; mm <= maxMillimeter; mm += 10) {
                const lineY = canvas.height - (mm * scaleFactor);
                if (lineY < 0) break; // Canvasの範囲外に出る場合は描画しない

                ctx.fillRect(rulerX, lineY, rulerWidth, 1); // 長い目盛り線
                ctx.fillText(`${mm}mm`, rulerX + rulerWidth + 2, lineY + 4);
            }

            // 5mmごとの短い目盛り線
            for (let mm = 5; mm <= maxMillimeter; mm += 10) {
                const lineY = canvas.height - (mm * scaleFactor);
                if (lineY < 0) break;
                ctx.fillRect(rulerX, lineY, rulerWidth / 2, 1); // 短い目盛り線
            }
        }


        // アニメーションの継続条件
        if (!animateGlow && currentHeight < targetHeight) { // 通常のアニメーションが完了していない場合
            requestAnimationFrame(animate);
        } else if (animateGlow && (timestamp - animationStartTime) < glowDuration) { // 光るアニメーションが継続時間内の場合
            requestAnimationFrame(animate);
        } else if (animateGlow && (timestamp - animationStartTime) >= glowDuration) {
             // 光るアニメーションが終了したら、通常の棒グラフを最終状態として一度描画し直す
            ctx.clearRect(0, 0, canvas.width, canvas.height); // クリア
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;
            ctx.shadowBlur = 6;
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(x, y, barWidth, currentHeight);
            // レンガも最終状態で描画し直す
            for (let i = 0; i * (brickHeight + brickGap) < currentHeight; i++) {
                let rowY = startY - (i * (brickHeight + brickGap) + brickHeight);
                if (rowY < y) rowY = y;
                if (rowY + brickHeight > startY) rowY = startY - brickHeight;

                if (i > 0) {
                    ctx.fillStyle = '#777';
                    ctx.fillRect(x, rowY + brickHeight + brickGap, barWidth, brickGap);
                }

                const offset = (i % 2 === 0) ? 0 : (barWidth / 2 - brickGap * 1.5) / 2;
                if (i % 2 !== 0) {
                    const halfBrickWidth = (barWidth - brickGap * 3) / 2;
                    ctx.fillStyle = brickColor;
                    ctx.fillRect(x + brickGap, rowY, halfBrickWidth, brickHeight);
                    ctx.fillRect(x + barWidth - brickGap - halfBrickWidth, rowY, halfBrickWidth, brickHeight);
                } else {
                    const fullBrickWidth = (barWidth - brickGap * 3) / 2;
                    ctx.fillStyle = brickColor;
                    ctx.fillRect(x + brickGap, rowY, fullBrickWidth, brickHeight);
                    ctx.fillRect(x + brickGap * 2 + fullBrickWidth, rowY, fullBrickWidth, brickHeight);
                    ctx.fillStyle = '#777';
                    ctx.fillRect(x + barWidth / 2 - brickGap / 2, rowY, brickGap, brickHeight);
                }
            }
            ctx.restore();
             // 目盛りも描画
            if (selectedRulerOption === 'show') { // アニメーション終了時にも選択されていれば描画
                for (let mm = 10; mm <= maxMillimeter; mm += 10) {
                    const lineY = canvas.height - (mm * scaleFactor);
                    if (lineY < 0) break;
                    ctx.fillRect(rulerX, lineY, rulerWidth, 1);
                    ctx.fillText(`${mm}mm`, rulerX + rulerWidth + 2, lineY + 4);
                }
                for (let mm = 5; mm <= maxMillimeter; mm += 10) {
                    const lineY = canvas.height - (mm * scaleFactor);
                    if (lineY < 0) break;
                    ctx.fillRect(rulerX, lineY, rulerWidth / 2, 1);
                }
            }
        }
      }
      requestAnimationFrame(animate);
    }


    // コンフェッティ演出（完璧な回答時）
    function launchConfetti() {
      const confettiCanvas = document.getElementById('confettiCanvas');
      confettiCanvas.style.display = 'block';
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
      const confettiCtx = confettiCanvas.getContext('2d');
      const particles = [];
      const colors = ['#fcf403', '#fc4a03', '#03fc03', '#0303fc', '#fc03d8'];
      
      for (let i = 0; i < 150; i++) { // パーティクル数を増やす
        particles.push({
          x: Math.random() * confettiCanvas.width,
          y: Math.random() * confettiCanvas.height - confettiCanvas.height,
          r: Math.random() * 8 + 3, // サイズを少し大きく
          d: Math.random() * 7 + 2, // 落ちる速度
          color: colors[Math.floor(Math.random() * colors.length)],
          tilt: Math.floor(Math.random() * 20) - 10, // 傾きを大きく
          tiltAngle: 0,
          tiltAngleIncrement: Math.random() * 0.1 + 0.05 // 傾き変化の速度
        });
      }
      
      function drawParticles() {
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        particles.forEach(p => {
          confettiCtx.beginPath();
          confettiCtx.lineWidth = p.r;
          confettiCtx.strokeStyle = p.color;
          confettiCtx.moveTo(p.x + p.tilt + Math.sin(p.tiltAngle) * p.r, p.y);
          confettiCtx.lineTo(p.x + p.tilt, p.y + p.r * Math.cos(p.tiltAngle));
          confettiCtx.stroke();
        });
      }
      
      let angle = 0;
      function updateParticles() {
        angle += 0.01;
        particles.forEach((p, i) => {
          p.y += (Math.cos(angle) + p.d + 1);
          p.x += Math.sin(angle);
          p.tiltAngle += p.tiltAngleIncrement; // 傾きを変化させる
          if (p.y > confettiCanvas.height) {
            particles[i] = {
              x: Math.random() * confettiCanvas.width,
              y: -10,
              r: p.r,
              d: p.d,
              color: p.color,
              tilt: p.tilt,
              tiltAngle: 0,
              tiltAngleIncrement: p.tiltAngleIncrement
            };
          }
        });
      }
      
      const confettiAnimation = setInterval(() => {
        drawParticles();
        updateParticles();
      }, 20);
      
      setTimeout(() => {
        clearInterval(confettiAnimation);
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        confettiCanvas.style.display = 'none';
      }, 3500); // 少し長く表示
    }

    // 現在の難易度設定に応じて棒の長さの範囲を取得する関数
    function getBarLengthRange() {
        const selectedDifficulty = document.querySelector('input[name="difficultyOption"]:checked').value;
        switch (selectedDifficulty) {
            case 'easy':
                return { min: 30, max: 80 }; // イージーモード: 30mm-80mm
            case 'hard':
                return { min: 10, max: 120 }; // ハードモード: 10mm-120mm
            case 'normal':
            default:
                return { min: 20, max: 100 }; // ノーマルモード: 20mm-100mm
        }
    }
    
    // 現在の難易度設定の最大ミリメートル値を取得する関数（目盛り描画用）
    function getMaxMillimeterForCurrentDifficulty() {
        const { max } = getBarLengthRange();
        // Canvasの高さに合わせて表示する最大値を調整
        // 棒が最大値の時にcanvasの高さに収まるように
        const maxPx = canvas.height / scaleFactor;
        return Math.min(max, Math.floor(maxPx / 10) * 10); // 10mm単位で切り捨てて表示
    }


    // 新ラウンド開始（自動移行）
    function startRound() {
      if (!gameActive) return; // ゲームが非アクティブなら開始しない

      clearInterval(timerInterval);
      
      // チャレンジモードの場合は残り時間リセットしない
      if (!isChallengeMode) {
        const timerSetting = parseInt(document.querySelector('input[name="timerOption"]:checked').value);
        timeLeft = timerSetting;
      }
      timeLeftSpan.textContent = timeLeft;

      hintUsed = false;
      document.getElementById('hint').disabled = false;
      guessInput.value = "";
      resultDiv.innerHTML = "";
      
      const { min, max } = getBarLengthRange(); // 選択された難易度に応じた範囲を取得
      actualLength = Math.floor(Math.random() * (max - min + 1)) + min;
      drawBar(); // 棒グラフを描画
      enableKeypad();
      guessInput.focus(); // 新しいラウンド開始時にテキストボックスにフォーカス

      timerInterval = setInterval(() => {
        timeLeft--;
        timeLeftSpan.textContent = timeLeft;
        if (timeLeft === 5) { // 残り5秒で警告音
            timerWarningSound.play();
        }
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          disableKeypad();
          
          if (isChallengeMode) {
              gameOverSound.play(); // ゲームオーバー音
              resultDiv.innerHTML = `時間切れ！ゲーム終了です！<br>最終スコア: ${score}点`;
              saveHighScores(); // チャレンジモードのハイスコアを保存
              gameActive = false; // ゲームを完全に非アクティブに
              document.getElementById('hint').disabled = true;
              document.getElementById('reset').textContent = 'もう一度プレイ';
          } else {
              resultDiv.innerHTML = `時間切れ！<br>実際の長さは <span style="color: blue;">${actualLength}mm</span> でした。<br>+0 ポイント`;
              combo = 0;
              comboSpan.textContent = combo;
              // 履歴に記録
              roundResults.push({
                  guess: null, // 時間切れなのでnull
                  actual: actualLength,
                  diff: '時間切れ',
                  points: 0
              });
              saveRoundHistory();

              round++;
              roundSpan.textContent = round;
              setTimeout(startRound, 2000); // 2秒後に次のラウンド
          }
        }
      }, 1000);
    }

    // ユーザー回答の評価
    function evaluateGuess() {
      if (timeLeft <= 0 || !gameActive) return; // 時間切れまたはゲーム非アクティブなら評価しない
      
      const guess = parseInt(guessInput.value, 10);
      if (isNaN(guess) || guessInput.value === "") {
        resultDiv.innerHTML = "数字を入力してください。";
        // チャレンジモードでない場合はタイマーを停止して次のラウンドへ
        if (!isChallengeMode) {
            clearInterval(timerInterval);
            disableKeypad();
            setTimeout(startRound, 1000); // 1秒後に次のラウンド
        }
        return;
      }
      
      const diff = Math.abs(actualLength - guess);
      let feedback = "";
      let points = 0;
      
      if (diff === 0) {
        feedback = "完璧！大正解です！";
        points = 10;
        combo++;
        comboSound.play(); // コンボ音
        launchConfetti();
        drawBar(true); // 棒を光らせるアニメーション
      } else if (diff <= 2) {
        feedback = "ほぼ正解！あと少し！";
        points = 7;
        combo = 0;
        correctSound.play(); // 成功音
      } else if (diff <= 5) {
        feedback = "近いです！頑張って！";
        points = 5;
        combo = 0;
        correctSound.play(); // 成功音
      } else if (diff <= 10) {
        feedback = "まあまあです。";
        points = 3;
        combo = 0;
        incorrectSound.play(); // 失敗音
      } else {
        feedback = "残念…";
        points = 0;
        combo = 0;
        incorrectSound.play(); // 失敗音
      }
      
      resultDiv.innerHTML =
        `あなたの予想: <span style="color: green;">${guess}mm</span><br>` +
        `実際の長さ: <span style="color: blue;">${actualLength}mm</span><br>` +
        `誤差: <span style="color: red;">${diff}mm</span><br>` +
        `${feedback}<br>` +
        `+${points} ポイント`;
      
      score += points;
      scoreSpan.textContent = score;
      comboSpan.textContent = combo;

      // 履歴に記録
      roundResults.push({
          guess: guess,
          actual: actualLength,
          diff: diff,
          points: points
      });
      saveRoundHistory();
      saveHighScores(); // スコア評価後にハイスコアをチェック＆保存

      // チャレンジモード以外は自動で次のラウンドへ
      if (!isChallengeMode) {
          clearInterval(timerInterval); // タイマーを停止
          disableKeypad(); // 評価中はキーパッドを無効化
          round++;
          roundSpan.textContent = round;
          setTimeout(startRound, 2000); // 2秒後に次のラウンド
      } else {
          // チャレンジモードの場合は、次の棒をすぐに描画し、入力欄をクリアする
          // タイマーは継続しているので、clearIntervalはしない
          guessInput.value = "";
          const { min, max } = getBarLengthRange();
          actualLength = Math.floor(Math.random() * (max - min + 1)) + min;
          drawBar(); // 棒グラフを描画
          enableKeypad();
          guessInput.focus(); // 次の棒描画後にテキストボックスにフォーカス
      }
    }

    // ヒント（各ラウンド1回のみ）
    document.getElementById('hint').addEventListener("click", function () {
      if (hintUsed || timeLeft <= 0 || !gameActive) return; // 時間切れ、ヒント使用済み、ゲーム非アクティブではヒント不可
      hintUsed = true;
      this.disabled = true;
      let hintMessage = "";
      
      const { min, max } = getBarLengthRange(); // 現在の難易度設定の範囲を取得
      const range = max - min;
      
      if (actualLength < min + range * 0.25) { // 下位25%
        hintMessage = "ヒント: 棒はかなり短いです。";
      } else if (actualLength < min + range * 0.5) { // 下位50% (中くらいの下半分)
        hintMessage = "ヒント: 棒はやや短いです。";
      } else if (actualLength < min + range * 0.75) { // 上位50% (中くらいの上半分)
        hintMessage = "ヒント: 棒はやや長いです。";
      } else { // 上位25%
        hintMessage = "ヒント: 棒はかなり長いです。";
      }
      resultDiv.innerHTML = hintMessage;
    });

    // 次のラウンド/新しいゲームを開始ボタン
    document.getElementById('reset').addEventListener("click", function () {
      initializeGame(); // モード選択から再初期化する
    });

    // 履歴表示ボタン
    showHistoryButton.addEventListener("click", function() {
        renderRoundHistory();
        roundHistoryDiv.style.display = 'block';
    });

    // 履歴クリアボタン
    clearHistoryButton.addEventListener("click", clearRoundHistory);

    // 履歴閉じるボタン
    closeHistoryButton.addEventListener("click", function() {
        roundHistoryDiv.style.display = 'none';
    });

    // ゲーム終了ボタンのイベントリスナー
    endGameButton.addEventListener("click", function() {
        if (confirm('ゲームを終了しますか？現在のスコアはリセットされます。')) {
            clearInterval(timerInterval); // タイマー停止
            disableKeypad(); // キーパッド無効化
            gameActive = false; // ゲームを非アクティブに
            resultDiv.innerHTML = `ゲーム終了！最終スコア: ${score}点<br>「${document.getElementById('reset').textContent}」ボタンで新しいゲームを開始できます。`;
            document.getElementById('hint').disabled = true; // ヒントも無効化
            document.getElementById('reset').textContent = '新しいゲームを開始'; // ボタンテキスト変更
            gameOverSound.play(); // ゲームオーバー音を鳴らす
            saveHighScores(); // 念のためスコアを保存
        }
    });

    // タイマー設定ラジオボタンのイベントリスナー
    timerOptionRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            // モードが切り替わったらゲームの状態をリセット
            initializeGame();
        });
    });

    // 難易度設定ラジオボタンのイベントリスナー
    difficultyOptionRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            // 難易度が切り替わったらゲームの状態をリセット
            initializeGame();
        });
    });

    // **目盛り表示オプションラジオボタンのイベントリスナー**
    rulerOptionRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            // 目盛り表示オプションが切り替わったら、棒グラフを再描画して変更を反映
            drawBar();
        });
    });

    // ゲーム開始
    window.onload = initializeGame;
  </script>
</body>
</html>
