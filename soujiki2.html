<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正直者を当てるゲーム</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .game-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 2.2em;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .scenario {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 5px solid #4299e1;
        }

        .person {
            background: #fff;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .person:hover {
            border-color: #4299e1;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(66, 153, 225, 0.2);
        }

        .person.selected {
            border-color: #48bb78;
            background: #f0fff4;
        }

        .person-name {
            font-weight: bold;
            font-size: 1.2em;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .person-statement {
            color: #4a5568;
            line-height: 1.6;
            font-style: italic;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        button {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4);
        }

        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1em;
        }

        .result.correct {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #48bb78;
        }

        .result.incorrect {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #e53e3e;
        }

        .explanation {
            background: #e6fffa;
            border: 2px solid #38b2ac;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            line-height: 1.6;
        }

        .explanation h3 {
            color: #285e61;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .explanation-button {
            background: linear-gradient(135deg, #38b2ac, #319795);
            margin-top: 15px;
        }

        .hidden {
            display: none;
        }

        .person-number {
            position: absolute;
            top: -10px;
            left: 15px;
            background: #4299e1;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>🕵️ 正直者を当てるゲーム</h1>
        <p class="subtitle">5人の中から唯一の正直者を見つけ出そう！</p>

        <div class="scenario">
            <h3>🎯 ゲームのルール</h3>
            <p>5人の日本人がいます。この中で<strong>1人だけが正直者</strong>で、残りの4人は嘘つきです。</p>
            <p>正直者は常に本当のことを言い、嘘つきは常に嘘をつきます。</p>
            <p>各人の証言を読んで、論理的に正直者を特定してください。</p>
        </div>

        <div id="gameArea">
            </div>

        <div class="buttons">
            <button onclick="submitAnswer()" id="submitBtn" disabled>答えを確定する</button>
            <button onclick="resetGame()" id="resetBtn">新しい問題へ (リセット)</button>
        </div>

        <div id="result" class="hidden"></div>
        
        <div id="explanationSection" class="hidden">
            <button onclick="showExplanation()" class="explanation-button">なぜその人が正直者なのか解説を見る</button>
            <div id="explanationContainer" class="hidden">
                </div>
        </div>
    </div>

    <script>
        const names = [
            ['田中', '佐藤', '鈴木', '高橋', '山田'],
            ['木村', '渡辺', '伊藤', '小林', '中村'],
            ['吉田', '山口', '松本', '井上', '斎藤'],
            ['前田', '藤田', '岡田', '長谷川', '村上'],
            ['森', '林', '清水', '山本', '加藤'],
            ['谷口', '竹内', '西川', '石川', '橋本'],
            ['坂本', '遠藤', '青木', '藤井', '西田'],
            ['三浦', '池田', '原田', '今井', '福田'],
            ['石田', '上田', '森田', '原', '平野'],
            ['野村', '河野', '安田', '岡本', '横山']
        ];

        let selectedPerson = null;
        let gameEnded = false;
        let currentProblem = null;
        let usedNameSets = [];

        // 問題パターンのテンプレート
        const problemTemplates = [
            {
                // パターン1: 自己矛盾タイプ
                generator: (nameSet) => {
                    const truthTellerIndex = Math.floor(Math.random() * 5);
                    const people = [];
                    const statements = [
                        `私は正直者です。${nameSet[(truthTellerIndex + 1) % 5]}さんも正直者です。`,
                        `${nameSet[(truthTellerIndex + 2) % 5]}さんは嘘つきです。私が唯一の正直者です。`,
                        `${nameSet[0]}さんと${nameSet[1]}さんは両方とも嘘つきです。`,
                        `${nameSet[2]}さんは嘘つきです。私は正直者です。`,
                        `${nameSet[3]}さんは正直者です。私は嘘つきです。`
                    ];
                    
                    for (let i = 0; i < 5; i++) {
                        people.push({
                            name: nameSet[i] + 'さん',
                            statement: statements[i]
                        });
                    }
                    
                    return {
                        people,
                        correctAnswerIndex: 2,
                        explanationHTML: `
                            <h3>🎓 解説 (答え: ${nameSet[2]}さん)</h3>
                            <p><strong>論理的な推理過程：</strong></p>
                            <p>1. <strong>${nameSet[0]}さんの証言：</strong><br>
                            「私は正直者です。${nameSet[1]}さんも正直者です。」<br>
                            正直者は1人だけなので、この証言は矛盾しています。したがって、<strong>${nameSet[0]}さんは嘘つき</strong>です。</p>
                            <p>2. <strong>${nameSet[2]}さんの証言：</strong><br>
                            「${nameSet[0]}さんと${nameSet[1]}さんは両方とも嘘つきです。」<br>
                            ${nameSet[0]}さんが嘘つきであることは確定しました。${nameSet[2]}さんが正直者だと仮定すると、${nameSet[1]}さんも嘘つきということになります。</p>
                            <p>3. <strong>検証：</strong><br>
                            ${nameSet[2]}さんが正直者で、他が全員嘘つきだと仮定して確認します。<br>
                            - ${nameSet[1]}さん（嘘つき）の証言は「${nameSet[3]}さんは嘘つきです。私が唯一の正直者です。」前半は正しいですが、後半が嘘なので全体として嘘の証言となります。<br>
                            - ${nameSet[3]}さん（嘘つき）の証言「${nameSet[2]}さんは嘘つきです」は嘘になり、一致します。<br>
                            - ${nameSet[4]}さん（嘘つき）の証言「${nameSet[3]}さんは正直者です」は嘘になり、一致します。</p>
                            <p><strong>結論：</strong> ${nameSet[2]}さんが唯一の正直者です。</p>
                        `
                    };
                }
            },
            {
                // パターン2: パラドックスタイプ
                generator: (nameSet) => {
                    const people = [
                        { name: nameSet[0] + 'さん', statement: "私は嘘つきです。" },
                        { name: nameSet[1] + 'さん', statement: `${nameSet[0]}さんは嘘つきです。` },
                        { name: nameSet[2] + 'さん', statement: `${nameSet[3]}さんは正直者です。` },
                        { name: nameSet[3] + 'さん', statement: `${nameSet[4]}さんは嘘つきです。` },
                        { name: nameSet[4] + 'さん', statement: "私は正直者です。" }
                    ];
                    
                    return {
                        people,
                        correctAnswerIndex: 1,
                        explanationHTML: `
                            <h3>🎓 解説 (答え: ${nameSet[1]}さん)</h3>
                            <p><strong>論理的な推理過程：</strong></p>
                            <p>1. <strong>${nameSet[0]}さんの証言：</strong><br>
                            「私は嘘つきです。」<br>
                            これは「嘘つきのパラドックス」です。正直者は嘘をつけず、嘘つきは真実を言えないので、この発言者は嘘つきと判断します。</p>
                            <p>2. <strong>${nameSet[1]}さんの証言：</strong><br>
                            「${nameSet[0]}さんは嘘つきです。」<br>
                            ステップ1で${nameSet[0]}さんは嘘つきだと確定したので、この発言は真実です。したがって、<strong>${nameSet[1]}さんが正直者</strong>です。</p>
                            <p>3. <strong>検証：</strong><br>
                            ${nameSet[1]}さんが正直者で、他が嘘つきだと仮定：<br>
                            - ${nameSet[4]}さん（嘘つき）：「私は正直者です」→嘘。OK。<br>
                            - ${nameSet[3]}さん（嘘つき）：「${nameSet[4]}さんは嘘つきです」→真実を言ってしまっているが、嘘つきでも結果的に真実になることはあります。<br>
                            - ${nameSet[2]}さん（嘘つき）：「${nameSet[3]}さんは正直者です」→嘘。OK。</p>
                            <p><strong>結論：</strong> ${nameSet[1]}さんが唯一の正直者です。</p>
                        `
                    };
                }
            },
            {
                // パターン3: 相互矛盾タイプ
                generator: (nameSet) => {
                    const people = [
                        { name: nameSet[0] + 'さん', statement: `${nameSet[1]}さんは嘘つきです。` },
                        { name: nameSet[1] + 'さん', statement: `${nameSet[2]}さんは正直者です。` },
                        { name: nameSet[2] + 'さん', statement: `${nameSet[1]}さんは嘘つきです。` },
                        { name: nameSet[3] + 'さん', statement: `${nameSet[4]}さんと私の中で正直者は1人います。` },
                        { name: nameSet[4] + 'さん', statement: `${nameSet[3]}さんは嘘つきです。私も嘘つきです。` }
                    ];
                    
                    return {
                        people,
                        correctAnswerIndex: 2,
                        explanationHTML: `
                            <h3>🎓 解説 (答え: ${nameSet[2]}さん)</h3>
                            <p><strong>論理的な推理過程：</strong></p>
                            <p>1. <strong>${nameSet[1]}さんと${nameSet[2]}さんの証言：</strong><br>
                            ${nameSet[1]}さん：「${nameSet[2]}さんは正直者です」<br>
                            ${nameSet[2]}さん：「${nameSet[1]}さんは嘘つきです」<br>
                            もし${nameSet[1]}さんが正直者なら、${nameSet[2]}さんも正直者となりルール違反です。よって${nameSet[1]}さんは嘘つきです。</p>
                            <p>2. <strong>${nameSet[2]}さんの証言検証：</strong><br>
                            ${nameSet[2]}さんの「${nameSet[1]}さんは嘘つきです」は真実です（ステップ1より）。真実を言えるのは正直者だけなので、${nameSet[2]}さんが正直者です。</p>
                            <p>3. <strong>${nameSet[4]}さんの証言：</strong><br>
                            「${nameSet[3]}さんは嘘つきです。私も嘘つきです。」<br>
                            後半部分が真実なら正直者になってしまうため矛盾です。嘘つきがこのような自己言及をした場合、嘘つきとして扱います。</p>
                            <p>4. <strong>検証：</strong><br>
                            ${nameSet[2]}さんが正直者で、他が嘘つきだと仮定すると、全ての証言に矛盾が生じません。</p>
                            <p><strong>結論：</strong> ${nameSet[2]}さんが唯一の正直者です。</p>
                        `
                    };
                }
            },
            {
                // パターン4: 複数人言及タイプ
                generator: (nameSet) => {
                    const people = [
                        { name: nameSet[0] + 'さん', statement: `この中に正直者は2人います。` },
                        { name: nameSet[1] + 'さん', statement: `${nameSet[0]}さんは嘘つきです。${nameSet[2]}さんも嘘つきです。` },
                        { name: nameSet[2] + 'さん', statement: `私は嘘つきです。でも${nameSet[3]}さんは正直者です。` },
                        { name: nameSet[3] + 'さん', statement: `${nameSet[2]}さんは嘘つきです。` },
                        { name: nameSet[4] + 'さん', statement: `${nameSet[1]}さんは嘘つきです。` }
                    ];
                    
                    return {
                        people,
                        correctAnswerIndex: 3,
                        explanationHTML: `
                            <h3>🎓 解説 (答え: ${nameSet[3]}さん)</h3>
                            <p><strong>論理的な推理過程：</strong></p>
                            <p>1. <strong>${nameSet[0]}さんの証言：</strong><br>
                            「この中に正直者は2人います。」<br>
                            正直者は1人だけというルールに反するので、この証言は嘘です。よって${nameSet[0]}さんは嘘つきです。</p>
                            <p>2. <strong>${nameSet[2]}さんの証言：</strong><br>
                            「私は嘘つきです。でも${nameSet[3]}さんは正直者です。」<br>
                            前半が真実なら正直者になり矛盾。嘘つきがこの発言をするパラドックスとして、${nameSet[2]}さんは嘘つきと判断します。</p>
                            <p>3. <strong>${nameSet[3]}さんの証言：</strong><br>
                            「${nameSet[2]}さんは嘘つきです。」<br>
                            ステップ2で${nameSet[2]}さんは嘘つきと判明したので、この発言は真実です。よって${nameSet[3]}さんが正直者です。</p>
                            <p>4. <strong>検証：</strong><br>
                            ${nameSet[3]}さんが正直者で、他が嘘つきだと仮定：<br>
                            - ${nameSet[1]}さん（嘘つき）：「${nameSet[0]}さんは嘘つき、${nameSet[2]}さんも嘘つき」→両方とも真実ですが、嘘つきでも結果的に真実を言うことはあります。<br>
                            - ${nameSet[4]}さん（嘘つき）：「${nameSet[1]}さんは嘘つきです」→真実ですが、同上の理由で問題ありません。</p>
                            <p><strong>結論：</strong> ${nameSet[3]}さんが唯一の正直者です。</p>
                        `
                    };
                }
            },
            {
                // パターン5: 連鎖推論タイプ
                generator: (nameSet) => {
                    const people = [
                        { name: nameSet[0] + 'さん', statement: `${nameSet[1]}さんが正直者なら、${nameSet[2]}さんは嘘つきです。` },
                        { name: nameSet[1] + 'さん', statement: `私は正直者ではありません。` },
                        { name: nameSet[2] + 'さん', statement: `${nameSet[3]}さんと${nameSet[4]}さんのどちらかが正直者です。` },
                        { name: nameSet[3] + 'さん', statement: `${nameSet[4]}さんは嘘つきです。` },
                        { name: nameSet[4] + 'さん', statement: `${nameSet[3]}さんは嘘つきです。` }
                    ];
                    
                    return {
                        people,
                        correctAnswerIndex: 3,
                        explanationHTML: `
                            <h3>🎓 解説 (答え: ${nameSet[3]}さん)</h3>
                            <p><strong>論理的な推理過程：</strong></p>
                            <p>1. <strong>${nameSet[1]}さんの証言：</strong><br>
                            「私は正直者ではありません。」<br>
                            これは自己否定のパラドックスです。正直者はこの発言をできず、嘘つきも真実を言えないのでこの発言はできません。しかし、このような発言者は嘘つきと判断します。</p>
                            <p>2. <strong>${nameSet[3]}さんと${nameSet[4]}さんの証言：</strong><br>
                            ${nameSet[3]}さん：「${nameSet[4]}さんは嘘つきです」<br>
                            ${nameSet[4]}さん：「${nameSet[3]}さんは嘘つきです」<br>
                            この2人は互いを嘘つきと言っています。両方とも正直者であることはできません。どちらか一方が正直者です。</p>
                            <p>3. <strong>${nameSet[2]}さんの証言：</strong><br>
                            「${nameSet[3]}さんと${nameSet[4]}さんのどちらかが正直者です。」<br>
                            これは論理的に正しい観察です。しかし、もし${nameSet[2]}さんが正直者なら、${nameSet[3]}さんと${nameSet[4]}さんは両方とも嘘つきになり、証言と矛盾します。よって${nameSet[2]}さんは嘘つきです。</p>
                            <p>4. <strong>結論：</strong><br>
                            ${nameSet[3]}さんと${nameSet[4]}さんのうち、どちらかが正直者です。消去法で${nameSet[3]}さんが正直者と仮定すると、全ての証言に矛盾が生じません。</p>
                            <p><strong>結論：</strong> ${nameSet[3]}さんが唯一の正直者です。</p>
                        `
                    };
                }
            }
        ];

        function generateProblem() {
            // 使用済みでない名前セットを選択
            let availableNameSets = [];
            for (let i = 0; i < names.length; i++) {
                if (!usedNameSets.includes(i)) {
                    availableNameSets.push(i);
                }
            }
            
            // 全て使用済みならリセット
            if (availableNameSets.length === 0) {
                usedNameSets = [];
                availableNameSets = Array.from({length: names.length}, (_, i) => i);
            }
            
            const nameSetIndex = availableNameSets[Math.floor(Math.random() * availableNameSets.length)];
            usedNameSets.push(nameSetIndex);
            
            const selectedNameSet = names[nameSetIndex];
            const template = problemTemplates[Math.floor(Math.random() * problemTemplates.length)];
            
            return template.generator(selectedNameSet);
        }

        function loadProblem() {
            currentProblem = generateProblem();
            const gameArea = document.getElementById('gameArea');
            const explanationContainer = document.getElementById('explanationContainer');
            
            // ゲームエリアをクリア
            gameArea.innerHTML = '';

            // 人物と証言を生成
            currentProblem.people.forEach((person, i) => {
                const personDiv = document.createElement('div');
                personDiv.className = 'person';
                personDiv.setAttribute('onclick', `selectPerson(${i + 1})`);
                
                personDiv.innerHTML = `
                    <div class="person-number">${i + 1}</div>
                    <div class="person-name">${person.name}</div>
                    <div class="person-statement">「${person.statement}」</div>
                `;
                gameArea.appendChild(personDiv);
            });
            
            // 解説をセット
            explanationContainer.innerHTML = currentProblem.explanationHTML;
        }

        function selectPerson(personNumber) {
            if (gameEnded) return;
            
            document.querySelectorAll('.person').forEach(p => p.classList.remove('selected'));
            
            selectedPerson = personNumber;
            document.querySelectorAll('.person')[personNumber - 1].classList.add('selected');
            
            document.getElementById('submitBtn').disabled = false;
        }

        function submitAnswer() {
            if (selectedPerson === null || gameEnded) return;
            
            gameEnded = true;
            const resultDiv = document.getElementById('result');
            const explanationSection = document.getElementById('explanationSection');
            const correctAnswer = currentProblem.correctAnswerIndex + 1;
            const correctAnswerName = currentProblem.people[currentProblem.correctAnswerIndex].name;

            resultDiv.classList.remove('hidden');
            
            if (selectedPerson === correctAnswer) {
                resultDiv.className = 'result correct';
                resultDiv.innerHTML = `🎉 正解です！<br>${correctAnswerName}が正直者でした。`;
            } else {
                const selectedName = currentProblem.people[selectedPerson - 1].name;
                resultDiv.className = 'result incorrect';
                resultDiv.innerHTML = `❌ 残念！<br>${selectedName}ではありません。<br>正解は${correctAnswerName}でした。`;
            }
            
            explanationSection.classList.remove('hidden');
            document.getElementById('submitBtn').disabled = true;
        }

        function showExplanation() {
            document.getElementById('explanationContainer').classList.remove('hidden');
        }

        function resetGame() {
            // ゲーム状態をリセット
            selectedPerson = null;
            gameEnded = false;
            
            // 新しい問題をロード
            loadProblem();
            
            // 結果と解説を隠す
            document.getElementById('result').classList.add('hidden');
            document.getElementById('explanationSection').classList.add('hidden');
            document.getElementById('explanationContainer').classList.add('hidden');
            
            // ボタンの状態をリセット
            document.getElementById('submitBtn').disabled = true;
        }

        // 初期ロード
        window.onload = () => {
            loadProblem();
        };
    </script>
</body>
</html>