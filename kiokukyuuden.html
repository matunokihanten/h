<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¨˜æ†¶ã®å®®æ®¿ - æ€è€ƒé€²åŒ–ç‰ˆ</title>
    <style>
        :root {
            --bg-color: #f0f2f5; --main-color: #ffffff; --primary-color: #007bff;
            --primary-hover-color: #0056b3; --text-color: #333; --light-text-color: #777;
            --border-color: #e0e0e0; --correct-color: #28a745; --incorrect-color: #dc3545;
            --life-color: #ff4757; --bonus-color: #fca311; --lock-color: #a0a0a0;
            --font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', sans-serif;
        }
        body {
            font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 20px; display: flex; justify-content: center; align-items: center; min-height: 100vh;
        }
        #app-container {
            width: 100%; max-width: 800px; background-color: var(--main-color);
            border-radius: 12px; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1); overflow: hidden;
        }
        .header { background-color: var(--primary-color); color: white; padding: 20px; text-align: center; }
        .header h1 { margin: 0; font-size: 1.8em; }
        .main-content { padding: 30px; }
        .screen { display: none; animation: fadeIn 0.5s ease-in-out; }
        .screen.active { display: block; }
        
        /* --- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ & ãƒ¬ãƒ™ãƒ«é¸æŠ --- */
        #start-screen p { text-align: center; margin-bottom: 20px; font-size: 1.1em; }
        #level-selection-area { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 15px; }
        .level-btn {
            background-color: var(--primary-color); color: white; border: none; border-radius: 8px;
            padding: 15px 10px; font-size: 1.2em; font-weight: bold; cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .level-btn:hover:not(:disabled) { background-color: var(--primary-hover-color); transform: translateY(-2px); }
        .level-btn:disabled { background-color: var(--lock-color); cursor: not-allowed; opacity: 0.7; }

        /* --- ã‚²ãƒ¼ãƒ ç”»é¢ --- */
        .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; font-size: 1.2em; font-weight: bold; }
        #life-display { color: var(--life-color); font-size: 1.5em; letter-spacing: 2px; }
        #palace-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .palace-room {
            border: 2px solid var(--border-color); border-radius: 8px; padding: 15px;
            text-align: center; transition: all 0.3s ease; background-color: #fafafa;
        }
        .palace-room.highlight { border-color: var(--primary-color); transform: scale(1.05); box-shadow: 0 4px 15px rgba(0, 123, 255, 0.2); }
        .room-number { font-size: 1.5em; font-weight: bold; color: var(--primary-color); }
        .room-item { font-size: 1.1em; margin-top: 10px; font-weight: bold; height: 2em; display: flex; justify-content: center; align-items: center; }
        .quiz-area { text-align: center; }
        #question-text { font-size: 1.3em; margin-bottom: 15px; }
        #answer-input {
            width: 80%; max-width: 300px; padding: 10px; font-size: 1.1em;
            border: 2px solid var(--border-color); border-radius: 8px; text-align: center; transition: border-color 0.3s;
        }
        #answer-input:focus { outline: none; border-color: var(--primary-color); }
        #answer-input.correct { border-color: var(--correct-color); }
        #answer-input.incorrect { border-color: var(--incorrect-color); animation: shake 0.5s; }
        #message-area { min-height: 2.2em; margin-top: 20px; font-size: 1.2em; font-weight: bold; color: var(--light-text-color); }
        .bonus-text { color: var(--bonus-color); animation: pop 0.5s ease; }

        /* --- ä¸­é–“ç”»é¢ (ãƒ¬ãƒ™ãƒ«ã‚¯ãƒªã‚¢, ãƒœãƒ¼ãƒŠã‚¹, çµæœ) --- */
        .interstitial-screen h2 { text-align: center; font-size: 1.8em; color: var(--primary-color); margin-bottom: 20px;}
        .interstitial-screen p { text-align: center; font-size: 1.2em; line-height: 1.5; }
        .interstitial-screen .button-container { display: flex; justify-content: center; gap: 15px; margin-top: 30px; }
        #mistake-review { margin-top: 20px; background-color: #f8f9fa; border-radius: 8px; padding: 15px; }
        #mistake-review h4 { margin-top: 0; text-align: center; color: var(--primary-color); }
        #mistake-list { list-style-type: none; padding: 0; text-align: center; }
        #bonus-inputs { display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .bonus-input { width: 70%; max-width: 250px; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } }
        @keyframes pop { 0% { transform: scale(0.8); opacity: 0; } 80% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>
    <div id="app-container">
        <header class="header"><h1>è¨˜æ†¶ã®å®®æ®¿ - æ€è€ƒé€²åŒ–ç‰ˆ</h1></header>
        <main class="main-content">
            <div id="start-screen" class="screen active">
                <p>ã‚¯ãƒªã‚¢ã—ãŸãƒ¬ãƒ™ãƒ«ã¾ã§é¸æŠã§ãã¾ã™ã€‚<br>è¨˜æ†¶åŠ›ã¨æ€è€ƒåŠ›ã®é™ç•Œã«æŒ‘æˆ¦ã—ã¾ã—ã‚‡ã†ã€‚</p>
                <div id="level-selection-area"></div>
            </div>
            <div id="game-screen" class="screen">
                <div class="game-header"><div id="level-display"></div><div id="score-display"></div><div id="life-display"></div></div>
                <div id="palace-grid"></div><div id="message-area"></div>
                <div id="quiz-area" style="display: none;"><p id="question-text"></p><form id="answer-form"><input type="text" id="answer-input" autocomplete="off"></form></div>
            </div>
            <div id="level-clear-screen" class="screen interstitial-screen">
                <h2 id="level-clear-title"></h2><p id="level-clear-details"></p>
                <div id="mistake-review" style="display: none;"><h4>å¾©ç¿’ãƒªã‚¹ãƒˆ</h4><ul id="mistake-list"></ul></div>
                <div class="button-container"><button id="bonus-stage-btn" class="btn">ãƒœãƒ¼ãƒŠã‚¹ã‚¹ãƒ†ãƒ¼ã‚¸ã¸</button><button id="next-level-btn-skip" class="btn">æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸</button></div>
            </div>
            <div id="bonus-stage-screen" class="screen interstitial-screen">
                <h2>é †ç•ªè¨˜æ†¶ãƒœãƒ¼ãƒŠã‚¹ã‚¹ãƒ†ãƒ¼ã‚¸</h2><p>è¨˜æ†¶ã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’ã€å‡ºç¾ã—ãŸé †ç•ªé€šã‚Šã«å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</p>
                <form id="bonus-form"><div id="bonus-inputs"></div><div class="button-container"><button type="submit" class="btn">å›ç­”ã™ã‚‹</button></div></form>
            </div>
            <div id="result-screen" class="screen interstitial-screen">
                <h2 id="result-title">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2><p id="result-details"></p>
                <div class="button-container"><button id="retry-btn" class="btn">ãƒ¬ãƒ™ãƒ«é¸æŠã¸æˆ»ã‚‹</button></div>
            </div>
        </main>
    </div>
<script>
(function() {
    const getEl = (id) => document.getElementById(id);
    const dom = {
        screens: { start: getEl('start-screen'), game: getEl('game-screen'), levelClear: getEl('level-clear-screen'), bonus: getEl('bonus-stage-screen'), result: getEl('result-screen') },
        levelSelectionArea: getEl('level-selection-area'),
        game: {
            level: getEl('level-display'), score: getEl('score-display'), life: getEl('life-display'),
            palaceGrid: getEl('palace-grid'), messageArea: getEl('message-area'), quizArea: getEl('quiz-area'),
            questionText: getEl('question-text'), answerForm: getEl('answer-form'), answerInput: getEl('answer-input'),
        },
        levelClear: { title: getEl('level-clear-title'), details: getEl('level-clear-details'), mistakeReview: getEl('mistake-review'), mistakeList: getEl('mistake-list'), bonusBtn: getEl('bonus-stage-btn'), skipBtn: getEl('next-level-btn-skip') },
        bonus: { form: getEl('bonus-form'), inputs: getEl('bonus-inputs') },
        result: { title: getEl('result-title'), details: getEl('result-details'), retryBtn: getEl('retry-btn') },
    };

    const config = {
        levels: { 1: [3,8], 2: [4,10], 3: [5,12], 4: [6,15], 5: [7,18], 6: [8,20], 7: [9,25], 8: [10,30] },
        itemPool: ['ã‚Šã‚“ã”','æ™‚è¨ˆ','æœ¬','éµ','å¸½å­','é´','è»Š','çŒ«','çŠ¬','æ¤…å­','æœº','èŠ±ç“¶','çª“','æ‰‰','é¡','çµµç”»','åœ°çƒå„€','é›»è©±','é‰›ç­†','æ¶ˆã—ã‚´ãƒ ','PC','å‚˜','æœˆ','å¤ªé™½','æ˜Ÿ','é›²','å·','å±±','æ£®','æµ·'],
        score: { correct: 100, combo: 50, bonus: 200 },
        initialLifes: 3,
        storageKey: 'memoryPalaceHighestLevel',
    };

    let state = {};

    const util = {
        shuffle: (arr) => arr.slice().sort(() => Math.random() - 0.5),
        sleep: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
        showScreen: (name) => { Object.values(dom.screens).forEach(s => s.classList.remove('active')); dom.screens[name].classList.add('active'); },
        getHighestLevel: () => parseInt(localStorage.getItem(config.storageKey) || '0'),
        setHighestLevel: (level) => { if (level > util.getHighestLevel()) localStorage.setItem(config.storageKey, level); },
    };

    const createLevelSelection = () => {
        const highestLevel = util.getHighestLevel();
        dom.levelSelectionArea.innerHTML = Object.keys(config.levels).map(level => {
            const unlocked = parseInt(level) <= highestLevel + 1;
            return `<button class="level-btn" data-level="${level}" ${!unlocked ? 'disabled' : ''}>${unlocked ? `Lv.${level}`: 'ğŸ”’'}</button>`;
        }).join('');
        dom.levelSelectionArea.querySelectorAll('.level-btn').forEach(btn => btn.addEventListener('click', () => initGame(parseInt(btn.dataset.level))));
    };

    const updateUI = () => {
        dom.game.level.textContent = `ãƒ¬ãƒ™ãƒ« ${state.level}`;
        dom.game.score.textContent = `ã‚¹ã‚³ã‚¢: ${state.score}`;
        dom.game.life.textContent = 'â™¥'.repeat(state.lifes) + 'â™¡'.repeat(config.initialLifes - state.lifes);
    };

    const displayQuestion = () => {
        if (state.currentQuestionIndex >= state.currentQuizData.length) return showLevelClearScreen();
        
        const question = state.currentQuizData[state.currentQuestionIndex];
        const { room, item, type } = question;
        
        if (type === 'room_from_item') {
            dom.game.questionText.innerHTML = `ã€Œ<span class="bonus-text">${item}</span>ã€ãŒã‚ã£ãŸã®ã¯ä½•ç•ªã®éƒ¨å±‹ï¼Ÿ`;
            dom.game.answerInput.placeholder = "éƒ¨å±‹ã®ç•ªå·ã‚’å…¥åŠ›";
            dom.game.answerInput.type = "number";
        } else {
            dom.game.questionText.textContent = `${room}ç•ªã®éƒ¨å±‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯ï¼Ÿ`;
            dom.game.answerInput.placeholder = "ã‚¢ã‚¤ãƒ†ãƒ åã‚’å…¥åŠ›";
            dom.game.answerInput.type = "text";
        }
        
        dom.game.answerInput.value = '';
        dom.game.answerInput.focus();
        dom.game.palaceGrid.querySelectorAll('.palace-room').forEach(el => el.classList.remove('highlight'));
    };
    
    const startQuiz = () => {
        state.gameStatus = 'quizzing';
        state.currentQuestionIndex = 0;
        state.mistakes = [];
        state.currentQuizData = util.shuffle(state.orderedQuizData).map(q => ({...q, type: Math.random() < 0.4 ? 'room_from_item' : 'item_from_room' }));

        dom.game.messageArea.textContent = 'ã‚¯ã‚¤ã‚ºã‚¿ã‚¤ãƒ ï¼';
        dom.game.quizArea.style.display = 'block';
        dom.game.palaceGrid.querySelectorAll('.room-item').forEach(el => el.textContent = '?');
        displayQuestion();
    };

    const startLevel = async () => {
        state.gameStatus = 'memorizing';
        const [roomCount, memorizeTime] = config.levels[state.level];
        updateUI();
        dom.game.quizArea.style.display = 'none';
        dom.game.messageArea.textContent = `å ´æ‰€ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨˜æ†¶ã—ã¦ãã ã•ã„...`;
        
        state.orderedQuizData = util.shuffle(config.itemPool).slice(0, roomCount).map((item, i) => ({ room: i + 1, item }));

        dom.game.palaceGrid.innerHTML = state.orderedQuizData.map(({ room, item }) => `<div class="palace-room"><div class="room-number">${room}</div><div class="room-item">${item}</div></div>`).join('');
        
        await util.sleep(memorizeTime * 1000);
        startQuiz();
    };
    
    const showLevelClearScreen = () => {
        state.gameStatus = 'level_cleared';
        util.setHighestLevel(state.level);
        util.showScreen('levelClear');
        dom.levelClear.title.textContent = `ãƒ¬ãƒ™ãƒ« ${state.level} ã‚¯ãƒªã‚¢ï¼`;
        
        const questionsCount = state.orderedQuizData.length;
        const correctCount = questionsCount - state.mistakes.length;
        dom.levelClear.details.innerHTML = `æ­£è§£æ•°: ${correctCount} / ${questionsCount}`;
        
        if (state.mistakes.length > 0) {
            dom.levelClear.mistakeReview.style.display = 'block';
            dom.levelClear.mistakeList.innerHTML = state.mistakes.map(m => `<li>${m.type === 'item_from_room' ? `${m.room}ç•ª` : `ã€Œ${m.item}ã€`} &rarr; ${m.correctAnswer}</li>`).join('');
        } else {
            dom.levelClear.mistakeReview.style.display = 'none';
            dom.levelClear.details.innerHTML += '<br>ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆï¼ç´ æ™´ã‚‰ã—ã„è¨˜æ†¶åŠ›ã§ã™ï¼';
        }
    };
    
    const startBonusStage = () => {
        state.gameStatus = 'bonus';
        util.showScreen('bonus');
        dom.bonus.inputs.innerHTML = state.orderedQuizData.map((_, i) => `<input type="text" class="bonus-input" placeholder="${i + 1}ç•ªç›®ã®ã‚¢ã‚¤ãƒ†ãƒ ">`).join('');
    };

    const handleBonusAnswer = (e) => {
        e.preventDefault();
        let correctBonusCount = 0;
        const inputs = e.target.querySelectorAll('.bonus-input');
        inputs.forEach((input, i) => {
            if (input.value.trim() === state.orderedQuizData[i].item) {
                correctBonusCount++;
                input.classList.add('correct');
            } else {
                input.classList.add('incorrect');
            }
        });
        const bonusScore = correctBonusCount * config.score.bonus;
        state.score += bonusScore;
        dom.game.messageArea.innerHTML = `ãƒœãƒ¼ãƒŠã‚¹: ${correctBonusCount}å•æ­£è§£ï¼<span class="bonus-text">+${bonusScore}ã‚¹ã‚³ã‚¢ï¼</span>`;
        setTimeout(goToNextLevel, 2000);
    };

    const goToNextLevel = () => {
        if (!config.levels[state.level + 1]) return gameOver(true);
        state.level++;
        initGame(state.level);
    };

    const gameOver = (allClear) => {
        state.gameStatus = 'finished';
        dom.result.title.textContent = allClear ? "å®Œå…¨åˆ¶è¦‡ï¼" : "ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼";
        dom.result.details.innerHTML = `æœ€çµ‚ã‚¹ã‚³ã‚¢: ${state.score}<br>åˆ°é”ãƒ¬ãƒ™ãƒ«: ${state.level}`;
        util.showScreen('result');
    };

    const handleAnswer = async (e) => {
        e.preventDefault();
        if (state.gameStatus !== 'quizzing') return;

        const userAnswer = dom.game.answerInput.value.trim();
        const question = state.currentQuizData[state.currentQuestionIndex];
        const correctAnswer = question.type === 'room_from_item' ? String(question.room) : question.item;
        const isCorrect = userAnswer === correctAnswer;
        
        dom.game.answerInput.classList.add(isCorrect ? 'correct' : 'incorrect');

        if (isCorrect) {
            state.combo++;
            const bonus = state.combo >= 2 ? config.score.combo * (state.combo - 1) : 0;
            const totalScore = config.score.correct + bonus;
            state.score += totalScore;
            dom.game.messageArea.innerHTML = `æ­£è§£ï¼ +${totalScore} <span class="bonus-text">${state.combo >= 2 ? `(${state.combo}é€£ç¶šæ­£è§£!)` : ''}</span>`;
        } else {
            state.combo = 0;
            state.lifes--;
            state.mistakes.push({ ...question, correctAnswer });
            dom.game.messageArea.textContent = `ä¸æ­£è§£... æ­£è§£ã¯ã€Œ${correctAnswer}ã€`;
        }
        
        updateUI();

        if (state.lifes <= 0) return setTimeout(() => gameOver(false), 1200);

        await util.sleep(1500);
        
        dom.game.answerInput.classList.remove('correct', 'incorrect');
        dom.game.messageArea.textContent = '';
        state.currentQuestionIndex++;
        displayQuestion();
    };
    
    const initGame = (level) => {
        state = { level, score: 0, lifes: config.initialLifes, combo: 0, gameStatus: 'initial' };
        util.showScreen('game');
        startLevel();
    };
    
    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
    dom.result.retryBtn.addEventListener('click', () => { createLevelSelection(); util.showScreen('start'); });
    dom.levelClear.bonusBtn.addEventListener('click', startBonusStage);
    dom.levelClear.skipBtn.addEventListener('click', goToNextLevel);
    dom.bonus.form.addEventListener('submit', handleBonusAnswer);
    dom.game.answerForm.addEventListener('submit', handleAnswer);

    // --- åˆæœŸåŒ– ---
    createLevelSelection();
})();
</script>
</body>
</html>
