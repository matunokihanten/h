<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>マッチ棒パズル</title>
  <style>
    body { font-family:"Arial",sans-serif;background:#f0f0f0;height:100vh;display:flex;justify-content:center;align-items:center;margin:0; }
    .game-container { background:#fff;border-radius:10px;box-shadow:0 4px 15px rgba(0,0,0,0.1);padding:30px;text-align:center;min-width:400px;}
    h1 {color:#333;}
    .game-info {display:flex;justify-content:space-between;margin-bottom:20px;font-weight:bold;color:#555;}
    .game-board {display:flex;justify-content:center;align-items:center;margin:20px 0;gap:10px;}
    .digit, .operator {position:relative;width:60px;height:100px;}
    .stick, .slot {position:absolute;border-radius:3px;transition:background 0.2s,transform 0.2s;}
    .stick {background:#c08040;box-shadow:1px 1px 3px rgba(0,0,0,0.3);cursor:pointer;}
    .stick.selected {background:#ff6347;transform:scale(1.1);z-index:10;}
    .slot {background:#e0e0e0;opacity:0.5;cursor:pointer;}
    .horizontal {width:40px;height:6px;}
    .vertical {width:6px;height:40px;}
    .message {font-weight:bold;font-size:16px;margin:10px 0 0 0; min-height: 19px;}
    .message.success{color:#28a745;}
    .message.error{color:#dc3545;}
    .controls {margin:20px 0 0 0;}
    .controls button{padding:10px 20px;font-size:16px;margin:0 5px;border:none;border-radius:5px;cursor:pointer;background-color:#007bff;color:#fff;transition:background 0.3s;}
    .controls button:disabled{background:#ccc;cursor:not-allowed;}
    .controls button:hover:not(:disabled){background:#0056b3;}
    .box {background:#f9f9f9;border:1px solid #ddd;border-radius:5px;padding:15px;margin-top:20px;font-size:14px;color:#333;text-align:left;}
  </style>
</head>
<body>
<div class="game-container">
  <h1>マッチ棒パズル</h1>
  <p>棒を動かして正しい式にしよう！</p>
  <div class="game-info">
    <div>レベル: <span id="level">1</span></div>
    <div>残り手数: <span id="moves-left">0</span></div>
    <div>スコア: <span id="score">0</span></div>
  </div>
  <div class="game-board" id="game-board"></div>
  <div class="message" id="message"></div>
  <div class="controls">
    <button id="btn-reset">リセット</button>
    <button id="btn-next" disabled>次のレベル</button>
    <button id="btn-hint">ヒント</button>
    <button id="btn-answer">答えを見る</button>
  </div>
  <div id="hint" class="box" style="display:none"></div>
  <div id="answer" class="box" style="display:none"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  /**
   * ==================================
   * DATA MODELS & DEFINITIONS
   * ==================================
   */

  const SEGMENT_POSITIONS = [
    { type: 'horizontal', x: 10, y: 0  }, // 0 (top)
    { type: 'vertical',   x: 50, y: 10 }, // 1 (top-right)
    { type: 'vertical',   x: 50, y: 50 }, // 2 (bottom-right)
    { type: 'horizontal', x: 10, y: 90 }, // 3 (bottom)
    { type: 'vertical',   x: 0,  y: 50 }, // 4 (bottom-left)
    { type: 'vertical',   x: 0,  y: 10 }, // 5 (top-left)
    { type: 'horizontal', x: 10, y: 45 }, // 6 (middle)
  ];

  const OPERATOR_POSITIONS = {
    // Note: To allow moving sticks between operators, we define a shared set of possible positions.
    // Here we define 2 slots for all operators for consistency.
    shared: [
        { type: 'horizontal', x: 10, y: 40 }, // For top bar of '='
        { type: 'horizontal', x: 10, y: 55 }, // For bottom bar of '='
        { type: 'horizontal', x: 10, y: 45 }, // For '-' and '+'
        { type: 'vertical',   x: 27, y: 30 }, // For '+'
    ]
  };

  const CHAR_PATTERNS = {
    '0': [1, 1, 1, 1, 1, 1, 0],
    '1': [0, 1, 1, 0, 0, 0, 0],
    '2': [1, 1, 0, 1, 1, 0, 1],
    '3': [1, 1, 1, 1, 0, 0, 1],
    '4': [0, 1, 1, 0, 0, 1, 1],
    '5': [1, 0, 1, 1, 0, 1, 1],
    '6': [1, 0, 1, 1, 1, 1, 1],
    '7': [1, 1, 1, 0, 0, 0, 0],
    '8': [1, 1, 1, 1, 1, 1, 1],
    '9': [1, 1, 1, 1, 0, 1, 1],
    // For operators, we map them to the 4 shared positions [top=, bottom=, middle-, middle|]
    '+': [0, 0, 1, 1],
    '-': [0, 0, 1, 0],
    '=': [1, 1, 0, 0],
  };

  const LEVELS = [
    { equation: '6+4=4', moves: 1, hint: "6を0に変えるか、+を-に変えて6を8に変えましょう。", answer: '0+4=4 または 8-4=4' },
    { equation: '8-3=3', moves: 1, hint: "数字と演算子、両方を変更する可能性があります。", answer: '6+3=9' },
    { equation: '5+7=2', moves: 2, hint: "答えが2になるように、左辺を考えましょう。", answer: '9-7=2' },
    { equation: '9-3=5', moves: 1, hint: "1本動かすだけで、数字2つを同時に変えられます。", answer: '8-3=5' },
  ];

  /**
   * ==================================
   * GAME STATE
   * ==================================
   */
  let state = {
    level: 0,
    score: 0,
    movesLeft: 0,
    board: [],
    selectedStick: null,
    isLevelComplete: false,
  };

  /**
   * ==================================
   * DOM ELEMENTS
   * ==================================
   */
  const levelEl = document.getElementById('level');
  const movesLeftEl = document.getElementById('moves-left');
  const scoreEl = document.getElementById('score');
  const gameBoardEl = document.getElementById('game-board');
  const messageEl = document.getElementById('message');
  const hintEl = document.getElementById('hint');
  const answerEl = document.getElementById('answer');
  const btnReset = document.getElementById('btn-reset');
  const btnNext = document.getElementById('btn-next');
  const btnHint = document.getElementById('btn-hint');
  const btnAnswer = document.getElementById('btn-answer');

  /**
   * ==================================
   * GAME LOGIC
   * ==================================
   */

  function equationToBoard(equationStr) {
    return [...equationStr].map(char => {
      const isDigit = !isNaN(parseInt(char));
      return {
        char: char,
        type: isDigit ? 'digit' : 'operator',
        sticks: [...(CHAR_PATTERNS[char] || [])]
      };
    });
  }

  function boardToEquation() {
    return state.board.map(cell => {
      for (const char in CHAR_PATTERNS) {
        const pattern = CHAR_PATTERNS[char];
        const cellIsDigit = cell.type === 'digit';
        const charIsDigit = !isNaN(parseInt(char));
        if (cellIsDigit === charIsDigit && pattern.length === cell.sticks.length && pattern.every((v, i) => v === cell.sticks[i])) {
          return char;
        }
      }
      return '?';
    }).join('');
  }

  function checkSolution() {
    const eq = boardToEquation();
    if (eq.includes('?')) return false;

    try {
      const [left, right] = eq.split('=');
      if (left === undefined || right === undefined) return false;
      return new Function(`return ${left}`)() === new Function(`return ${right}`)();
    } catch (e) {
      return false;
    }
  }

  function startLevel(levelIndex) {
    if (levelIndex >= LEVELS.length) {
      updateMessage("全レベルクリア！おめでとうございます！ 🏆", 'success');
      btnNext.disabled = true;
      return;
    }

    const levelData = LEVELS[levelIndex];
    state.level = levelIndex;
    state.movesLeft = levelData.moves;
    state.board = equationToBoard(levelData.equation);
    state.selectedStick = null;
    state.isLevelComplete = false;
    state.score = 1000;

    btnNext.disabled = true;
    hintEl.style.display = 'none';
    answerEl.style.display = 'none';
    updateMessage("");

    render();
  }
  
  function updateMessage(text, className = '') {
    messageEl.textContent = text;
    messageEl.className = `message ${className}`;
  }

  /**
   * ==================================
   * RENDERING
   * ==================================
   */
  function render() {
    levelEl.textContent = state.level + 1;
    movesLeftEl.textContent = state.movesLeft;
    scoreEl.textContent = state.score;
    gameBoardEl.innerHTML = '';

    state.board.forEach((cell, charIndex) => {
      const container = document.createElement('div');
      container.className = cell.type;

      const positions = cell.type === 'digit' ? SEGMENT_POSITIONS : OPERATOR_POSITIONS.shared;
      const totalSlots = positions.length;

      for (let stickIndex = 0; stickIndex < totalSlots; stickIndex++) {
          const pos = positions[stickIndex];
          // Skip rendering non-existent slots for operators
          if(cell.type === 'operator' && !cell.sticks.hasOwnProperty(stickIndex)) continue;

          const hasStick = cell.sticks[stickIndex] === 1;

          if (!hasStick && cell.type === 'operator' && !CHAR_PATTERNS['+'].includes(1, stickIndex) && !CHAR_PATTERNS['='].includes(1, stickIndex) && !CHAR_PATTERNS['-'].includes(1, stickIndex)) {
               if( (stickIndex==0 && cell.char!='=') || (stickIndex==1 && cell.char!='=') || (stickIndex==2 && cell.char!='+' && cell.char!='-')||(stickIndex==3 && cell.char!='+')) continue;
          }

          const el = document.createElement('div');
          el.className = `${hasStick ? 'stick' : 'slot'} ${pos.type}`;
          el.style.left = `${pos.x}px`;
          el.style.top = `${pos.y}px`;
          el.dataset.charIndex = charIndex;
          el.dataset.stickIndex = stickIndex;

          if (hasStick) {
              if (state.selectedStick && state.selectedStick.charIndex === charIndex && state.selectedStick.stickIndex === stickIndex) {
                  el.classList.add('selected');
              }
              el.onclick = handleStickClick;
          } else {
              el.onclick = handleSlotClick;
          }
          container.appendChild(el);
      }
      gameBoardEl.appendChild(container);
    });
  }

  /**
   * ==================================
   * EVENT HANDLERS
   * ==================================
   */
  function handleStickClick(e) {
    if (state.isLevelComplete || state.movesLeft <= 0) return;

    const charIndex = +e.target.dataset.charIndex;
    const stickIndex = +e.target.dataset.stickIndex;

    if (state.selectedStick && state.selectedStick.charIndex === charIndex && state.selectedStick.stickIndex === stickIndex) {
      state.selectedStick = null;
    } else {
      state.selectedStick = { charIndex, stickIndex };
    }
    render();
  }

  function handleSlotClick(e) {
    if (state.isLevelComplete || !state.selectedStick || state.movesLeft <= 0) return;

    const src = state.selectedStick;
    const dest = {
      charIndex: +e.target.dataset.charIndex,
      stickIndex: +e.target.dataset.stickIndex,
    };
    
    // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
    // The restriction preventing movement between digits and symbols has been removed.
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    state.board[src.charIndex].sticks[src.stickIndex] = 0;
    state.board[dest.charIndex].sticks[dest.stickIndex] = 1;

    state.movesLeft--;
    state.score = Math.max(0, state.score - 100);
    state.selectedStick = null;

    updateMessage("");
    render();

    if (state.movesLeft === 0) {
      setTimeout(() => {
        if (checkSolution()) {
          updateMessage("正解です！おめでとうございます！ 🎉", 'success');
          state.score += 500;
          scoreEl.textContent = state.score;
          state.isLevelComplete = true;
          btnNext.disabled = false;
        } else {
          updateMessage("残念、間違いです。もう一度挑戦！", 'error');
          state.score = Math.max(0, state.score - 200);
          scoreEl.textContent = state.score;
        }
      }, 300);
    }
  }

  btnReset.onclick = () => startLevel(state.level);
  btnNext.onclick = () => startLevel(state.level + 1);
  btnHint.onclick = () => {
    hintEl.textContent = `ヒント: ${LEVELS[state.level].hint}`;
    hintEl.style.display = 'block';
  };
  btnAnswer.onclick = () => {
    answerEl.textContent = `答え: ${LEVELS[state.level].answer}`;
    answerEl.style.display = 'block';
  };

  /**
   * ==================================
   * INITIALIZE GAME
   * ==================================
   */
  startLevel(0);
});
</script>
</body>
</html>
