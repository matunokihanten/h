<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ディレクトリ構成ZIPツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* 簡単なスタイル調整 */
        body {
            font-family: 'Inter', sans-serif;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-8 font-[Noto Sans JP]">
    <div class="container bg-white rounded-2xl shadow-xl p-6 sm:p-10">
        <header class="text-center mb-10">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">ディレクトリ構成ZIPツール</h1>
            <p class="mt-3 text-gray-600">テキストからZIPを生成したり、ZIPから構成を読み込んだりできます。</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <div class="flex flex-col bg-gray-50 p-6 rounded-xl border border-gray-200">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800">1. テキストからZIPを生成</h2>
                <p class="mb-4 text-gray-500">下のテキストエリアにディレクトリ構成を入力し、「ZIP生成」ボタンを押してください。<br><small class="text-gray-400">例: my-project/
├── src/
│   ├── index.js(console.log('Hello, World!'))
│   └── style.css
├── public/
│   └── index.html(<h1>Hello, HTML</h1>)
└── package.json</small></p>
                <textarea id="structureInput" class="w-full h-80 p-4 border border-gray-300 rounded-lg resize-y focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="my-project/
├── src/
│   ├── index.js(console.log('Hello, World!'))
│   └── style.css
├── public/
│   └── index.html(<h1>Hello, HTML</h1>)
└── package.json"></textarea>
                <button id="generateBtn" class="mt-4 w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform transform hover:scale-105 shadow-md">
                    ZIPを生成してダウンロード
                </button>
                <div id="generateMessage" class="mt-3 text-sm text-green-600"></div>
            </div>

            <div class="flex flex-col bg-gray-50 p-6 rounded-xl border border-gray-200">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800">2. ZIPから構成を読み込み</h2>
                <p class="mb-4 text-gray-500">ZIPファイルを選択すると、下のエリアにディレクトリ構成が表示されます。</p>
                <div class="relative">
                    <input type="file" id="zipInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" accept=".zip">
                    <label for="zipInput" class="w-full flex justify-center items-center bg-white text-blue-600 font-semibold py-3 px-4 rounded-lg border-2 border-dashed border-blue-400 hover:bg-blue-50 cursor-pointer transition">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                        ZIPファイルを選択
                    </label>
                </div>
                <pre id="structureOutput" class="w-full h-80 mt-4 p-4 border bg-white border-gray-300 rounded-lg overflow-auto whitespace-pre-wrap break-words text-sm"></pre>
                <div id="readMessage" class="mt-3 text-sm text-red-600"></div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM要素の取得 ---
        const structureInput = document.getElementById('structureInput');
        const generateBtn = document.getElementById('generateBtn');
        const generateMessage = document.getElementById('generateMessage');
        const zipInput = document.getElementById('zipInput');
        const structureOutput = document.getElementById('structureOutput');
        const readMessage = document.getElementById('readMessage');

        // --- ZIP生成機能 ---
        generateBtn.addEventListener('click', () => {
            const text = structureInput.value.trim();
            if (!text) {
                generateMessage.textContent = 'テキストが入力されていません。';
                generateMessage.className = 'mt-3 text-sm text-red-600';
                return;
            }

            generateMessage.textContent = 'ZIPファイルを生成中...';
            generateMessage.className = 'mt-3 text-sm text-blue-600';

            try {
                const zip = new JSZip();
                const lines = text.split('\n');
                const pathStack = [];

                lines.forEach(line => {
                    if (line.trim() === '') return;

                    // 行からインデントと名前、そしてコンテンツを抽出
                    const indentationMatch = line.match(/^(\s*│?\s*[├└]──\s*)/);
                    let rawName = indentationMatch ? line.substring(indentationMatch[0].length) : line;
                    let content = '';

                    const contentMatch = rawName.match(/\((.*?)\)$/);
                    if (contentMatch) {
                        content = contentMatch[1];
                        rawName = rawName.replace(contentMatch[0], '');
                    }

                    const name = rawName.trim();
                    const isDirectory = name.endsWith('/');
                    const cleanName = isDirectory ? name.slice(0, -1) : name;

                    // インデントの深さを計算
                    const depth = indentationMatch ? (indentationMatch[0].replace(/[│├└─\s]/g, '').length + indentationMatch[0].match(/ /g).length) / 4 : 0;
                    
                    // パススタックを調整
                    while (depth < pathStack.length) {
                        pathStack.pop();
                    }

                    const currentPath = pathStack.join('/');
                    const fullPath = currentPath ? `${currentPath}/${cleanName}` : cleanName;

                    if (isDirectory) {
                        zip.folder(fullPath);
                        pathStack.push(cleanName);
                    } else {
                        zip.file(fullPath, content);
                    }
                });

                // ZIPファイルを生成してダウンロード
                zip.generateAsync({ type: "blob" })
                    .then(function(content) {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(content);
                        link.download = "structure.zip";
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        generateMessage.textContent = 'ZIPファイルの生成が完了しました！';
                        generateMessage.className = 'mt-3 text-sm text-green-600';
                    });

            } catch (error) {
                console.error("ZIP generation error:", error);
                generateMessage.textContent = 'ZIPファイルの生成に失敗しました。入力形式を確認してください。';
                generateMessage.className = 'mt-3 text-sm text-red-600';
            }
        });

        // --- ZIP読み込み機能 ---
        zipInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            readMessage.textContent = '';
            structureOutput.textContent = 'ZIPファイルを読み込み中...';

            const reader = new FileReader();
            reader.onload = function(e) {
                JSZip.loadAsync(e.target.result)
                    .then(function(zip) {
                        const filePaths = Object.keys(zip.files);
                        if (filePaths.length === 0) {
                            structureOutput.textContent = 'ZIPファイルは空です。';
                            return;
                        }
                        const tree = buildTree(filePaths);
                        structureOutput.textContent = formatTree(tree);
                    })
                    .catch(function(err) {
                        console.error("ZIP reading error:", err);
                        structureOutput.textContent = '';
                        readMessage.textContent = 'ZIPファイルの読み込みに失敗しました。ファイルが破損している可能性があります。';
                    });
            };
            reader.readAsArrayBuffer(file);
        });

        /**
         * ファイルパスのリストからツリー構造のオブジェクトを生成するヘルパー関数
         * @param {string[]} paths - ファイルパスの配列
         * @returns {object} - ツリー構造のオブジェクト
         */
        function buildTree(paths) {
            const tree = {};
            paths.forEach(path => {
                const parts = path.split('/').filter(p => p);
                let currentLevel = tree;
                parts.forEach((part, index) => {
                    if (!currentLevel[part]) {
                        // パスの最後か、末尾に'/'がある場合はディレクトリとして扱う
                        const isDirectory = (index < parts.length - 1) || path.endsWith('/');
                        currentLevel[part] = isDirectory ? {} : null;
                    }
                    if (typeof currentLevel[part] === 'object' && currentLevel[part] !== null) {
                        currentLevel = currentLevel[part];
                    }
                });
            });
            return tree;
        }

        /**
         * ツリー構造のオブジェクトを整形されたテキストに変換するヘルパー関数
         * @param {object} node - ツリー構造のノード
         * @param {string} prefix - インデント用の接頭辞
         * @returns {string} - 整形されたツリーテキスト
         */
        function formatTree(node, prefix = '') {
            let result = '';
            const entries = Object.entries(node);
            entries.forEach(([key, value], index) => {
                const isLast = index === entries.length - 1;
                const connector = isLast ? '└── ' : '├── ';
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                
                result += prefix + connector + key + '\n';
                if (value !== null && typeof value === 'object') {
                    result += formatTree(value, newPrefix);
                }
            });
            return result;
        }

    </script>
</body>
</html>
